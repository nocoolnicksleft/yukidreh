
RGBMatrix2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000842  00800100  00000c52  00000ce6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000015a  00800942  00800942  00001528  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  00001528  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000002e8  00000000  00000000  00001548  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000b2f  00000000  00000000  00001830  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000002a6  00000000  00000000  0000235f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000c58  00000000  00000000  00002605  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000180  00000000  00000000  00003260  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000032b  00000000  00000000  000033e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000002fd  00000000  00000000  0000370b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 53 00 	jmp	0xa6	; 0xa6 <__vector_17>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	19 e0       	ldi	r17, 0x09	; 9
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 e5       	ldi	r30, 0x52	; 82
  7c:	fc e0       	ldi	r31, 0x0C	; 12
  7e:	02 c0       	rjmp	.+4      	; 0x84 <.do_copy_data_start>

00000080 <.do_copy_data_loop>:
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0

00000084 <.do_copy_data_start>:
  84:	a2 34       	cpi	r26, 0x42	; 66
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <.do_copy_data_loop>

0000008a <__do_clear_bss>:
  8a:	1a e0       	ldi	r17, 0x0A	; 10
  8c:	a2 e4       	ldi	r26, 0x42	; 66
  8e:	b9 e0       	ldi	r27, 0x09	; 9
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ac 39       	cpi	r26, 0x9C	; 156
  96:	b1 07       	cpc	r27, r17
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 e0 05 	call	0xbc0	; 0xbc0 <main>
  9e:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <__vector_17>:
Purpose:	Initialize I/O, Setup SPI Hardware
Parameters:	None
Return:		None
*/
ISR (SPI_STC_vect) 
{
  a6:	1f 92       	push	r1
  a8:	0f 92       	push	r0
  aa:	0f b6       	in	r0, 0x3f	; 63
  ac:	0f 92       	push	r0
  ae:	11 24       	eor	r1, r1
  b0:	2f 93       	push	r18
  b2:	3f 93       	push	r19
  b4:	8f 93       	push	r24
  b6:	9f 93       	push	r25
  b8:	ef 93       	push	r30
  ba:	ff 93       	push	r31
	cli();	//Halt Interrupts
  bc:	f8 94       	cli

	value=SPDR;	//Get the data from the SPI bus and put it into the temporary frame buffer
  be:	8e b5       	in	r24, 0x2e	; 46
  c0:	80 93 47 09 	sts	0x0947, r24

	if(!command_mode && value != '*'){
  c4:	80 91 46 09 	lds	r24, 0x0946
  c8:	88 23       	and	r24, r24
  ca:	81 f5       	brne	.+96     	; 0x12c <__vector_17+0x86>
  cc:	80 91 47 09 	lds	r24, 0x0947
  d0:	8a 32       	cpi	r24, 0x2A	; 42
  d2:	61 f1       	breq	.+88     	; 0x12c <__vector_17+0x86>
		buffer[frame_index] = value;
  d4:	e0 91 42 09 	lds	r30, 0x0942
  d8:	f0 e0       	ldi	r31, 0x00	; 0
  da:	80 91 47 09 	lds	r24, 0x0947
  de:	ed 56       	subi	r30, 0x6D	; 109
  e0:	f6 4f       	sbci	r31, 0xF6	; 246
  e2:	80 83       	st	Z, r24
		
		frame_index = ((frame_index + 1) & 0x7F) ;	//Frame index counts from 0-63 then wraps back to 0
  e4:	80 91 42 09 	lds	r24, 0x0942
  e8:	8f 5f       	subi	r24, 0xFF	; 255
  ea:	8f 77       	andi	r24, 0x7F	; 127
  ec:	80 93 42 09 	sts	0x0942, r24
		SPDR = buffer[frame_index];	//Pass the data along to the next matrix in line.
  f0:	e0 91 42 09 	lds	r30, 0x0942
  f4:	f0 e0       	ldi	r31, 0x00	; 0
  f6:	ed 56       	subi	r30, 0x6D	; 109
  f8:	f6 4f       	sbci	r31, 0xF6	; 246
  fa:	80 81       	ld	r24, Z
  fc:	8e bd       	out	0x2e, r24	; 46
		
		byte_count++;	//Keep track o f how many bytes we receive
  fe:	80 91 13 0a 	lds	r24, 0x0A13
 102:	90 91 14 0a 	lds	r25, 0x0A14
 106:	01 96       	adiw	r24, 0x01	; 1
 108:	90 93 14 0a 	sts	0x0A14, r25
 10c:	80 93 13 0a 	sts	0x0A13, r24

		//If we've received enough data for all of the boards currently connected, tell the main firmware we can post a new frame!
		if(byte_count == NUM_LEDS*2){
 110:	80 91 13 0a 	lds	r24, 0x0A13
 114:	90 91 14 0a 	lds	r25, 0x0A14
 118:	80 38       	cpi	r24, 0x80	; 128
 11a:	91 05       	cpc	r25, r1
 11c:	39 f4       	brne	.+14     	; 0x12c <__vector_17+0x86>
			new_frame = 1;	//Post a new frame when we receive enough bytes for all of the LEDS in the 'system'
 11e:	81 e0       	ldi	r24, 0x01	; 1
 120:	80 93 98 0a 	sts	0x0A98, r24
			byte_count=0;	//Reset the byte count
 124:	10 92 14 0a 	sts	0x0A14, r1
 128:	10 92 13 0a 	sts	0x0A13, r1
		}
	}

	if (command_mode) {
 12c:	80 91 46 09 	lds	r24, 0x0946
 130:	88 23       	and	r24, r24
 132:	09 f4       	brne	.+2      	; 0x136 <__vector_17+0x90>
 134:	8f c0       	rjmp	.+286    	; 0x254 <__vector_17+0x1ae>

	   if (byte_count == 1) {
 136:	80 91 13 0a 	lds	r24, 0x0A13
 13a:	90 91 14 0a 	lds	r25, 0x0A14
 13e:	01 97       	sbiw	r24, 0x01	; 1
 140:	09 f0       	breq	.+2      	; 0x144 <__vector_17+0x9e>
 142:	5a c0       	rjmp	.+180    	; 0x1f8 <__vector_17+0x152>
           
		   if (value < SUBCOMMANDS) {
 144:	80 91 47 09 	lds	r24, 0x0947
 148:	81 31       	cpi	r24, 0x11	; 17
 14a:	08 f0       	brcs	.+2      	; 0x14e <__vector_17+0xa8>
 14c:	7a c0       	rjmp	.+244    	; 0x242 <__vector_17+0x19c>

		    current_subcommand = value;
 14e:	80 91 47 09 	lds	r24, 0x0947
 152:	80 93 4a 09 	sts	0x094A, r24

		   	if (current_subcommand == SUBCOMMAND_SETALL) { // Buffer
 156:	80 91 4a 09 	lds	r24, 0x094A
 15a:	88 23       	and	r24, r24
 15c:	c9 f1       	breq	.+114    	; 0x1d0 <__vector_17+0x12a>
		
				bytes_expected = 4;

			} else if (current_subcommand == SUBCOMMAND_SETNUMBOARDS) { // Stuff
 15e:	80 91 4a 09 	lds	r24, 0x094A
 162:	81 30       	cpi	r24, 0x01	; 1
 164:	a9 f0       	breq	.+42     	; 0x190 <__vector_17+0xea>

			    bytes_expected = 2;

			} else if (current_subcommand == SUBCOMMAND_SCROLLX) { // Draw
 166:	80 91 4a 09 	lds	r24, 0x094A
 16a:	82 30       	cpi	r24, 0x02	; 2
 16c:	09 f4       	brne	.+2      	; 0x170 <__vector_17+0xca>
 16e:	41 c0       	rjmp	.+130    	; 0x1f2 <__vector_17+0x14c>

			    bytes_expected = 2;

			} else if (current_subcommand == SUBCOMMAND_SCROLLY) { // Draw
 170:	80 91 4a 09 	lds	r24, 0x094A
 174:	83 30       	cpi	r24, 0x03	; 3
 176:	61 f0       	breq	.+24     	; 0x190 <__vector_17+0xea>

			    bytes_expected = 2;

			} else if (current_subcommand == SUBCOMMAND_SETFORECOLOR) { // Draw
 178:	80 91 4a 09 	lds	r24, 0x094A
 17c:	84 30       	cpi	r24, 0x04	; 4
 17e:	c9 f1       	breq	.+114    	; 0x1f2 <__vector_17+0x14c>

			    bytes_expected = 4;

			} else if (current_subcommand == SUBCOMMAND_SETBACKCOLOR) { // Draw
 180:	80 91 4a 09 	lds	r24, 0x094A
 184:	85 30       	cpi	r24, 0x05	; 5
 186:	21 f1       	breq	.+72     	; 0x1d0 <__vector_17+0x12a>

			    bytes_expected = 4;

			} else if (current_subcommand == SUBCOMMAND_CLEAR) { // Draw
 188:	80 91 4a 09 	lds	r24, 0x094A
 18c:	86 30       	cpi	r24, 0x06	; 6
 18e:	11 f4       	brne	.+4      	; 0x194 <__vector_17+0xee>

			    bytes_expected = 2;
 190:	82 e0       	ldi	r24, 0x02	; 2
 192:	2f c0       	rjmp	.+94     	; 0x1f2 <__vector_17+0x14c>

			} else if (current_subcommand == SUBCOMMAND_DRAWPOINT) { // Draw
 194:	80 91 4a 09 	lds	r24, 0x094A
 198:	87 30       	cpi	r24, 0x07	; 7
 19a:	51 f1       	breq	.+84     	; 0x1f0 <__vector_17+0x14a>

			    bytes_expected = 3;

			} else if (current_subcommand == SUBCOMMAND_DRAWCHAR) { // Draw
 19c:	80 91 4a 09 	lds	r24, 0x094A
 1a0:	88 30       	cpi	r24, 0x08	; 8
 1a2:	b1 f0       	breq	.+44     	; 0x1d0 <__vector_17+0x12a>

			    bytes_expected = 4;

			} else if (current_subcommand == SUBCOMMAND_DRAWROW) { // Draw
 1a4:	80 91 4a 09 	lds	r24, 0x094A
 1a8:	89 30       	cpi	r24, 0x09	; 9
 1aa:	11 f1       	breq	.+68     	; 0x1f0 <__vector_17+0x14a>

			    bytes_expected = 3;

			} else if (current_subcommand == SUBCOMMAND_DRAWCOL) {  // Draw
 1ac:	80 91 4a 09 	lds	r24, 0x094A
 1b0:	8a 30       	cpi	r24, 0x0A	; 10
 1b2:	f1 f0       	breq	.+60     	; 0x1f0 <__vector_17+0x14a>

			    bytes_expected = 3;

			} else if (current_subcommand == SUBCOMMAND_DRAWALL) { // Draw
 1b4:	80 91 4a 09 	lds	r24, 0x094A
 1b8:	8b 30       	cpi	r24, 0x0B	; 11
 1ba:	11 f4       	brne	.+4      	; 0x1c0 <__vector_17+0x11a>

			    bytes_expected = 10;
 1bc:	8a e0       	ldi	r24, 0x0A	; 10
 1be:	19 c0       	rjmp	.+50     	; 0x1f2 <__vector_17+0x14c>

			} else if (current_subcommand == SUBCOMMAND_SHIFTLEFT) { // Buffer
 1c0:	80 91 4a 09 	lds	r24, 0x094A
 1c4:	8c 30       	cpi	r24, 0x0C	; 12
 1c6:	21 f0       	breq	.+8      	; 0x1d0 <__vector_17+0x12a>

			    bytes_expected = 4;

			} else if (current_subcommand == SUBCOMMAND_SHIFTRIGHT) { // Buffer
 1c8:	80 91 4a 09 	lds	r24, 0x094A
 1cc:	8d 30       	cpi	r24, 0x0D	; 13
 1ce:	11 f4       	brne	.+4      	; 0x1d4 <__vector_17+0x12e>

			    bytes_expected = 4;
 1d0:	84 e0       	ldi	r24, 0x04	; 4
 1d2:	0f c0       	rjmp	.+30     	; 0x1f2 <__vector_17+0x14c>

			} else if (current_subcommand == SUBCOMMAND_DRAWLINEV) { // Buffer
 1d4:	80 91 4a 09 	lds	r24, 0x094A
 1d8:	8e 30       	cpi	r24, 0x0E	; 14
 1da:	21 f0       	breq	.+8      	; 0x1e4 <__vector_17+0x13e>

			    bytes_expected = 5;

			} else if (current_subcommand == SUBCOMMAND_DRAWLINEH) { // Buffer
 1dc:	80 91 4a 09 	lds	r24, 0x094A
 1e0:	8f 30       	cpi	r24, 0x0F	; 15
 1e2:	11 f4       	brne	.+4      	; 0x1e8 <__vector_17+0x142>

			    bytes_expected = 5;
 1e4:	85 e0       	ldi	r24, 0x05	; 5
 1e6:	05 c0       	rjmp	.+10     	; 0x1f2 <__vector_17+0x14c>

			} else if (current_subcommand == SUBCOMMAND_CLEARPOINT) { // Draw
 1e8:	80 91 4a 09 	lds	r24, 0x094A
 1ec:	80 31       	cpi	r24, 0x10	; 16
 1ee:	49 f5       	brne	.+82     	; 0x242 <__vector_17+0x19c>

			    bytes_expected = 3;
 1f0:	83 e0       	ldi	r24, 0x03	; 3
 1f2:	80 93 49 09 	sts	0x0949, r24
 1f6:	25 c0       	rjmp	.+74     	; 0x242 <__vector_17+0x19c>

		   }

	   } else {

	   		if (!bytes_expected) {
 1f8:	80 91 49 09 	lds	r24, 0x0949
 1fc:	88 23       	and	r24, r24
 1fe:	19 f4       	brne	.+6      	; 0x206 <__vector_17+0x160>


					// Not a valid command. Pack things up.
					process_command_now = 0;
 200:	10 92 48 09 	sts	0x0948, r1
 204:	16 c0       	rjmp	.+44     	; 0x232 <__vector_17+0x18c>


			} else {

					// Write bytes to buffer
					buffer[byte_count] = value;
 206:	e0 91 13 0a 	lds	r30, 0x0A13
 20a:	f0 91 14 0a 	lds	r31, 0x0A14
 20e:	80 91 47 09 	lds	r24, 0x0947
 212:	ed 56       	subi	r30, 0x6D	; 109
 214:	f6 4f       	sbci	r31, 0xF6	; 246
 216:	80 83       	st	Z, r24

			   		if (byte_count == bytes_expected) {
 218:	20 91 13 0a 	lds	r18, 0x0A13
 21c:	30 91 14 0a 	lds	r19, 0x0A14
 220:	80 91 49 09 	lds	r24, 0x0949
 224:	90 e0       	ldi	r25, 0x00	; 0
 226:	28 17       	cp	r18, r24
 228:	39 07       	cpc	r19, r25
 22a:	59 f4       	brne	.+22     	; 0x242 <__vector_17+0x19c>

						process_command_now = 1;
 22c:	81 e0       	ldi	r24, 0x01	; 1
 22e:	80 93 48 09 	sts	0x0948, r24

						command_mode = 0;
 232:	10 92 46 09 	sts	0x0946, r1

						byte_count = 0;
 236:	10 92 14 0a 	sts	0x0A14, r1
 23a:	10 92 13 0a 	sts	0x0A13, r1

						bytes_expected = 0;
 23e:	10 92 49 09 	sts	0x0949, r1

			}

	   }

	   byte_count++;
 242:	80 91 13 0a 	lds	r24, 0x0A13
 246:	90 91 14 0a 	lds	r25, 0x0A14
 24a:	01 96       	adiw	r24, 0x01	; 1
 24c:	90 93 14 0a 	sts	0x0A14, r25
 250:	80 93 13 0a 	sts	0x0A13, r24

	}

	if ((value == '*') && (byte_count == 0)) {
 254:	80 91 47 09 	lds	r24, 0x0947
 258:	8a 32       	cpi	r24, 0x2A	; 42
 25a:	e9 f4       	brne	.+58     	; 0x296 <__vector_17+0x1f0>
 25c:	80 91 13 0a 	lds	r24, 0x0A13
 260:	90 91 14 0a 	lds	r25, 0x0A14
 264:	89 2b       	or	r24, r25
 266:	b9 f4       	brne	.+46     	; 0x296 <__vector_17+0x1f0>

	    buffer[byte_count] = value;
 268:	e0 91 13 0a 	lds	r30, 0x0A13
 26c:	f0 91 14 0a 	lds	r31, 0x0A14
 270:	80 91 47 09 	lds	r24, 0x0947
 274:	ed 56       	subi	r30, 0x6D	; 109
 276:	f6 4f       	sbci	r31, 0xF6	; 246
 278:	80 83       	st	Z, r24

		command_mode=1;
 27a:	81 e0       	ldi	r24, 0x01	; 1
 27c:	80 93 46 09 	sts	0x0946, r24

		bytes_expected = 0;
 280:	10 92 49 09 	sts	0x0949, r1

		byte_count++;
 284:	80 91 13 0a 	lds	r24, 0x0A13
 288:	90 91 14 0a 	lds	r25, 0x0A14
 28c:	01 96       	adiw	r24, 0x01	; 1
 28e:	90 93 14 0a 	sts	0x0A14, r25
 292:	80 93 13 0a 	sts	0x0A13, r24

	}


	sei();
 296:	78 94       	sei
}
 298:	ff 91       	pop	r31
 29a:	ef 91       	pop	r30
 29c:	9f 91       	pop	r25
 29e:	8f 91       	pop	r24
 2a0:	3f 91       	pop	r19
 2a2:	2f 91       	pop	r18
 2a4:	0f 90       	pop	r0
 2a6:	0f be       	out	0x3f, r0	; 63
 2a8:	0f 90       	pop	r0
 2aa:	1f 90       	pop	r1
 2ac:	18 95       	reti

000002ae <update_singlepoint>:
/*********************************************************
			Buffer Update Routines
*********************************************************/

void update_singlepoint(uint8_t x, uint8_t y)
{
 2ae:	cf 93       	push	r28
 2b0:	df 93       	push	r29
 2b2:	e6 2f       	mov	r30, r22
	int bufferPosition;
	
	bufferPosition = (y * COLS) + x;
 2b4:	f0 e0       	ldi	r31, 0x00	; 0
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	af 01       	movw	r20, r30
 2ba:	23 e0       	ldi	r18, 0x03	; 3
 2bc:	44 0f       	add	r20, r20
 2be:	55 1f       	adc	r21, r21
 2c0:	2a 95       	dec	r18
 2c2:	e1 f7       	brne	.-8      	; 0x2bc <update_singlepoint+0xe>
 2c4:	48 0f       	add	r20, r24
 2c6:	59 1f       	adc	r21, r25

	if (pointBuffer[y] & (1 << x)) {
 2c8:	e5 57       	subi	r30, 0x75	; 117
 2ca:	f6 4f       	sbci	r31, 0xF6	; 246
 2cc:	20 81       	ld	r18, Z
 2ce:	30 e0       	ldi	r19, 0x00	; 0
 2d0:	02 c0       	rjmp	.+4      	; 0x2d6 <update_singlepoint+0x28>
 2d2:	35 95       	asr	r19
 2d4:	27 95       	ror	r18
 2d6:	8a 95       	dec	r24
 2d8:	e2 f7       	brpl	.-8      	; 0x2d2 <update_singlepoint+0x24>
 2da:	fa 01       	movw	r30, r20
 2dc:	e5 5b       	subi	r30, 0xB5	; 181
 2de:	f6 4f       	sbci	r31, 0xF6	; 246
 2e0:	da 01       	movw	r26, r20
 2e2:	a8 5a       	subi	r26, 0xA8	; 168
 2e4:	b5 4f       	sbci	r27, 0xF5	; 245
 2e6:	ea 01       	movw	r28, r20
 2e8:	c8 5e       	subi	r28, 0xE8	; 232
 2ea:	d5 4f       	sbci	r29, 0xF5	; 245
 2ec:	20 ff       	sbrs	r18, 0
 2ee:	09 c0       	rjmp	.+18     	; 0x302 <update_singlepoint+0x54>

		red_frame[bufferPosition] = foreColor[COLOR_CHANNEL_RED];
 2f0:	80 91 15 0a 	lds	r24, 0x0A15
 2f4:	80 83       	st	Z, r24
		green_frame[bufferPosition] = foreColor[COLOR_CHANNEL_GREEN];
 2f6:	80 91 16 0a 	lds	r24, 0x0A16
 2fa:	8c 93       	st	X, r24
		blue_frame[bufferPosition] = foreColor[COLOR_CHANNEL_BLUE];
 2fc:	80 91 17 0a 	lds	r24, 0x0A17
 300:	08 c0       	rjmp	.+16     	; 0x312 <update_singlepoint+0x64>

	} else {

		red_frame[bufferPosition] = backColor[COLOR_CHANNEL_RED];
 302:	80 91 99 0a 	lds	r24, 0x0A99
 306:	80 83       	st	Z, r24
		green_frame[bufferPosition] = backColor[COLOR_CHANNEL_GREEN];
 308:	80 91 9a 0a 	lds	r24, 0x0A9A
 30c:	8c 93       	st	X, r24
		blue_frame[bufferPosition] = backColor[COLOR_CHANNEL_BLUE];
 30e:	80 91 9b 0a 	lds	r24, 0x0A9B
 312:	88 83       	st	Y, r24

	}
}
 314:	df 91       	pop	r29
 316:	cf 91       	pop	r28
 318:	08 95       	ret

0000031a <update_buffer_row>:

void update_buffer_row(uint8_t y)
{
 31a:	af 92       	push	r10
 31c:	bf 92       	push	r11
 31e:	cf 92       	push	r12
 320:	df 92       	push	r13
 322:	ef 92       	push	r14
 324:	ff 92       	push	r15
 326:	0f 93       	push	r16
 328:	1f 93       	push	r17
 32a:	cf 93       	push	r28
 32c:	df 93       	push	r29

	int bufferPosition;
	
	for (int i = 0; i < COLS; i++) {

		bufferPosition = (y * COLS) + i;
 32e:	e8 2f       	mov	r30, r24
 330:	f0 e0       	ldi	r31, 0x00	; 0
 332:	8f 01       	movw	r16, r30
 334:	33 e0       	ldi	r19, 0x03	; 3
 336:	00 0f       	add	r16, r16
 338:	11 1f       	adc	r17, r17
 33a:	3a 95       	dec	r19
 33c:	e1 f7       	brne	.-8      	; 0x336 <update_buffer_row+0x1c>

		if (pointBuffer[y] & (1 << i)) {
 33e:	e5 57       	subi	r30, 0x75	; 117
 340:	f6 4f       	sbci	r31, 0xF6	; 246
 342:	80 81       	ld	r24, Z
 344:	68 2f       	mov	r22, r24
 346:	70 e0       	ldi	r23, 0x00	; 0
						
			red_frame[bufferPosition] = foreColor[COLOR_CHANNEL_RED];
 348:	a0 90 15 0a 	lds	r10, 0x0A15
			green_frame[bufferPosition] = foreColor[COLOR_CHANNEL_GREEN];
 34c:	b0 90 16 0a 	lds	r11, 0x0A16
			blue_frame[bufferPosition] = foreColor[COLOR_CHANNEL_BLUE];
 350:	c0 90 17 0a 	lds	r12, 0x0A17

		} else {

			red_frame[bufferPosition] = backColor[COLOR_CHANNEL_RED];
 354:	d0 90 99 0a 	lds	r13, 0x0A99
			green_frame[bufferPosition] = backColor[COLOR_CHANNEL_GREEN];
 358:	e0 90 9a 0a 	lds	r14, 0x0A9A
			blue_frame[bufferPosition] = backColor[COLOR_CHANNEL_BLUE];
 35c:	f0 90 9b 0a 	lds	r15, 0x0A9B
 360:	40 e0       	ldi	r20, 0x00	; 0
 362:	50 e0       	ldi	r21, 0x00	; 0
 364:	ca 01       	movw	r24, r20
 366:	80 0f       	add	r24, r16
 368:	91 1f       	adc	r25, r17
	
	for (int i = 0; i < COLS; i++) {

		bufferPosition = (y * COLS) + i;

		if (pointBuffer[y] & (1 << i)) {
 36a:	9b 01       	movw	r18, r22
 36c:	04 2e       	mov	r0, r20
 36e:	02 c0       	rjmp	.+4      	; 0x374 <update_buffer_row+0x5a>
 370:	35 95       	asr	r19
 372:	27 95       	ror	r18
 374:	0a 94       	dec	r0
 376:	e2 f7       	brpl	.-8      	; 0x370 <update_buffer_row+0x56>
 378:	fc 01       	movw	r30, r24
 37a:	e5 5b       	subi	r30, 0xB5	; 181
 37c:	f6 4f       	sbci	r31, 0xF6	; 246
 37e:	dc 01       	movw	r26, r24
 380:	a8 5a       	subi	r26, 0xA8	; 168
 382:	b5 4f       	sbci	r27, 0xF5	; 245
 384:	ec 01       	movw	r28, r24
 386:	c8 5e       	subi	r28, 0xE8	; 232
 388:	d5 4f       	sbci	r29, 0xF5	; 245
 38a:	20 ff       	sbrs	r18, 0
 38c:	04 c0       	rjmp	.+8      	; 0x396 <update_buffer_row+0x7c>
						
			red_frame[bufferPosition] = foreColor[COLOR_CHANNEL_RED];
 38e:	a0 82       	st	Z, r10
			green_frame[bufferPosition] = foreColor[COLOR_CHANNEL_GREEN];
 390:	bc 92       	st	X, r11
			blue_frame[bufferPosition] = foreColor[COLOR_CHANNEL_BLUE];
 392:	c8 82       	st	Y, r12
 394:	03 c0       	rjmp	.+6      	; 0x39c <update_buffer_row+0x82>

		} else {

			red_frame[bufferPosition] = backColor[COLOR_CHANNEL_RED];
 396:	d0 82       	st	Z, r13
			green_frame[bufferPosition] = backColor[COLOR_CHANNEL_GREEN];
 398:	ec 92       	st	X, r14
			blue_frame[bufferPosition] = backColor[COLOR_CHANNEL_BLUE];
 39a:	f8 82       	st	Y, r15
void update_buffer_row(uint8_t y)
{

	int bufferPosition;
	
	for (int i = 0; i < COLS; i++) {
 39c:	4f 5f       	subi	r20, 0xFF	; 255
 39e:	5f 4f       	sbci	r21, 0xFF	; 255
 3a0:	48 30       	cpi	r20, 0x08	; 8
 3a2:	51 05       	cpc	r21, r1
 3a4:	f9 f6       	brne	.-66     	; 0x364 <update_buffer_row+0x4a>

		}

	}

}
 3a6:	df 91       	pop	r29
 3a8:	cf 91       	pop	r28
 3aa:	1f 91       	pop	r17
 3ac:	0f 91       	pop	r16
 3ae:	ff 90       	pop	r15
 3b0:	ef 90       	pop	r14
 3b2:	df 90       	pop	r13
 3b4:	cf 90       	pop	r12
 3b6:	bf 90       	pop	r11
 3b8:	af 90       	pop	r10
 3ba:	08 95       	ret

000003bc <update_buffer>:

void update_buffer()
{
 3bc:	1f 93       	push	r17
 3be:	10 e0       	ldi	r17, 0x00	; 0

	for (int i = 0; i < ROWS; i++) update_buffer_row(i);
 3c0:	81 2f       	mov	r24, r17
 3c2:	0e 94 8d 01 	call	0x31a	; 0x31a <update_buffer_row>
 3c6:	1f 5f       	subi	r17, 0xFF	; 255
 3c8:	18 30       	cpi	r17, 0x08	; 8
 3ca:	d1 f7       	brne	.-12     	; 0x3c0 <update_buffer+0x4>

}
 3cc:	1f 91       	pop	r17
 3ce:	08 95       	ret

000003d0 <draw_clear>:

void draw_clear()
{
 3d0:	eb e8       	ldi	r30, 0x8B	; 139
 3d2:	f9 e0       	ldi	r31, 0x09	; 9
	
	for (int i = 0; i < ROWS; i++) pointBuffer[i] = 0;
 3d4:	11 92       	st	Z+, r1
 3d6:	89 e0       	ldi	r24, 0x09	; 9
 3d8:	e3 39       	cpi	r30, 0x93	; 147
 3da:	f8 07       	cpc	r31, r24
 3dc:	d9 f7       	brne	.-10     	; 0x3d4 <draw_clear+0x4>

}
 3de:	08 95       	ret

000003e0 <shift_right>:


void shift_right(uint8_t r, uint8_t g, uint8_t b)
{
 3e0:	98 2f       	mov	r25, r24
 3e2:	2e e3       	ldi	r18, 0x3E	; 62
 3e4:	30 e0       	ldi	r19, 0x00	; 0
 3e6:	d9 01       	movw	r26, r18
 3e8:	11 96       	adiw	r26, 0x01	; 1

	for (int i = 62; i > 0; i--)
	{
		red_frame[i + 1] = red_frame[i];
 3ea:	f9 01       	movw	r30, r18
 3ec:	e5 5b       	subi	r30, 0xB5	; 181
 3ee:	f6 4f       	sbci	r31, 0xF6	; 246
 3f0:	80 81       	ld	r24, Z
 3f2:	fd 01       	movw	r30, r26
 3f4:	e5 5b       	subi	r30, 0xB5	; 181
 3f6:	f6 4f       	sbci	r31, 0xF6	; 246
 3f8:	80 83       	st	Z, r24
		green_frame[i + 1] = green_frame[i];
 3fa:	f9 01       	movw	r30, r18
 3fc:	e8 5a       	subi	r30, 0xA8	; 168
 3fe:	f5 4f       	sbci	r31, 0xF5	; 245
 400:	80 81       	ld	r24, Z
 402:	fd 01       	movw	r30, r26
 404:	e8 5a       	subi	r30, 0xA8	; 168
 406:	f5 4f       	sbci	r31, 0xF5	; 245
 408:	80 83       	st	Z, r24
		blue_frame[i + 1] = blue_frame[i];
 40a:	f9 01       	movw	r30, r18
 40c:	e8 5e       	subi	r30, 0xE8	; 232
 40e:	f5 4f       	sbci	r31, 0xF5	; 245
 410:	80 81       	ld	r24, Z
 412:	a8 5e       	subi	r26, 0xE8	; 232
 414:	b5 4f       	sbci	r27, 0xF5	; 245
 416:	8c 93       	st	X, r24


void shift_right(uint8_t r, uint8_t g, uint8_t b)
{

	for (int i = 62; i > 0; i--)
 418:	21 50       	subi	r18, 0x01	; 1
 41a:	30 40       	sbci	r19, 0x00	; 0
 41c:	21 f7       	brne	.-56     	; 0x3e6 <shift_right+0x6>
		red_frame[i + 1] = red_frame[i];
		green_frame[i + 1] = green_frame[i];
		blue_frame[i + 1] = blue_frame[i];
	}

	red_frame[0] = r;
 41e:	90 93 4b 09 	sts	0x094B, r25
	green_frame[0] = g;
 422:	60 93 58 0a 	sts	0x0A58, r22
	blue_frame[0] = b;
 426:	40 93 18 0a 	sts	0x0A18, r20


}
 42a:	08 95       	ret

0000042c <shift_left>:

void shift_left(uint8_t r, uint8_t g, uint8_t b)
{
 42c:	98 2f       	mov	r25, r24
 42e:	a0 e0       	ldi	r26, 0x00	; 0
 430:	b0 e0       	ldi	r27, 0x00	; 0

	for (int i = 0; i < 63; i++)
	{
		red_frame[i] = red_frame[i + 1];
 432:	9d 01       	movw	r18, r26
 434:	2f 5f       	subi	r18, 0xFF	; 255
 436:	3f 4f       	sbci	r19, 0xFF	; 255
 438:	f9 01       	movw	r30, r18
 43a:	e5 5b       	subi	r30, 0xB5	; 181
 43c:	f6 4f       	sbci	r31, 0xF6	; 246
 43e:	80 81       	ld	r24, Z
 440:	fd 01       	movw	r30, r26
 442:	e5 5b       	subi	r30, 0xB5	; 181
 444:	f6 4f       	sbci	r31, 0xF6	; 246
 446:	80 83       	st	Z, r24
		green_frame[i] = green_frame[i + 1];
 448:	f9 01       	movw	r30, r18
 44a:	e8 5a       	subi	r30, 0xA8	; 168
 44c:	f5 4f       	sbci	r31, 0xF5	; 245
 44e:	80 81       	ld	r24, Z
 450:	fd 01       	movw	r30, r26
 452:	e8 5a       	subi	r30, 0xA8	; 168
 454:	f5 4f       	sbci	r31, 0xF5	; 245
 456:	80 83       	st	Z, r24
		blue_frame[i] = blue_frame[i + 1];
 458:	f9 01       	movw	r30, r18
 45a:	e8 5e       	subi	r30, 0xE8	; 232
 45c:	f5 4f       	sbci	r31, 0xF5	; 245
 45e:	80 81       	ld	r24, Z
 460:	a8 5e       	subi	r26, 0xE8	; 232
 462:	b5 4f       	sbci	r27, 0xF5	; 245
 464:	8c 93       	st	X, r24
}

void shift_left(uint8_t r, uint8_t g, uint8_t b)
{

	for (int i = 0; i < 63; i++)
 466:	2f 33       	cpi	r18, 0x3F	; 63
 468:	31 05       	cpc	r19, r1
 46a:	11 f0       	breq	.+4      	; 0x470 <shift_left+0x44>
 46c:	d9 01       	movw	r26, r18
 46e:	e1 cf       	rjmp	.-62     	; 0x432 <shift_left+0x6>
		red_frame[i] = red_frame[i + 1];
		green_frame[i] = green_frame[i + 1];
		blue_frame[i] = blue_frame[i + 1];
	}

	red_frame[63] = r;
 470:	90 93 8a 09 	sts	0x098A, r25
	green_frame[63] = g;
 474:	60 93 97 0a 	sts	0x0A97, r22
	blue_frame[63] = b;
 478:	40 93 57 0a 	sts	0x0A57, r20

}
 47c:	08 95       	ret

0000047e <draw_character>:
	}
}
*/

void draw_character(int8_t x, int8_t y, char character)
{
 47e:	af 92       	push	r10
 480:	bf 92       	push	r11
 482:	cf 92       	push	r12
 484:	df 92       	push	r13
 486:	ef 92       	push	r14
 488:	ff 92       	push	r15
 48a:	0f 93       	push	r16
 48c:	1f 93       	push	r17
 48e:	cf 93       	push	r28
 490:	df 93       	push	r29
 492:	08 2f       	mov	r16, r24

    if (x > 7) return;
 494:	88 30       	cpi	r24, 0x08	; 8
 496:	0c f0       	brlt	.+2      	; 0x49a <draw_character+0x1c>
 498:	67 c0       	rjmp	.+206    	; 0x568 <draw_character+0xea>
	if (y > 7) return;
 49a:	68 30       	cpi	r22, 0x08	; 8
 49c:	0c f0       	brlt	.+2      	; 0x4a0 <draw_character+0x22>
 49e:	64 c0       	rjmp	.+200    	; 0x568 <draw_character+0xea>
	if (x < -7) return;
 4a0:	89 3f       	cpi	r24, 0xF9	; 249
 4a2:	0c f4       	brge	.+2      	; 0x4a6 <draw_character+0x28>
 4a4:	61 c0       	rjmp	.+194    	; 0x568 <draw_character+0xea>
	if (y < -7) return;
 4a6:	69 3f       	cpi	r22, 0xF9	; 249
 4a8:	0c f4       	brge	.+2      	; 0x4ac <draw_character+0x2e>
 4aa:	5e c0       	rjmp	.+188    	; 0x568 <draw_character+0xea>

    int8_t startcol = x;

    int8_t startrow = y;

	if (x < 0) {
 4ac:	87 fd       	sbrc	r24, 7
 4ae:	02 c0       	rjmp	.+4      	; 0x4b4 <draw_character+0x36>
 4b0:	50 e0       	ldi	r21, 0x00	; 0
 4b2:	03 c0       	rjmp	.+6      	; 0x4ba <draw_character+0x3c>

		startcol = (int8_t)(-x);
 4b4:	58 2f       	mov	r21, r24
 4b6:	51 95       	neg	r21
 4b8:	00 e0       	ldi	r16, 0x00	; 0

	    startcol = 0;

	}

	if (y < 0) {
 4ba:	67 fd       	sbrc	r22, 7
 4bc:	02 c0       	rjmp	.+4      	; 0x4c2 <draw_character+0x44>
 4be:	80 e0       	ldi	r24, 0x00	; 0
 4c0:	03 c0       	rjmp	.+6      	; 0x4c8 <draw_character+0x4a>

		startrow = (int8_t)(-y);
 4c2:	86 2f       	mov	r24, r22
 4c4:	81 95       	neg	r24
 4c6:	60 e0       	ldi	r22, 0x00	; 0
	if (x < -7) return;
	if (y < -7) return;

	uint8_t * characterptr = (uint8_t *)f6x8;
	
	characterptr += 8 * (uint8_t)character;
 4c8:	e4 2f       	mov	r30, r20
 4ca:	f0 e0       	ldi	r31, 0x00	; 0
 4cc:	73 e0       	ldi	r23, 0x03	; 3
 4ce:	ee 0f       	add	r30, r30
 4d0:	ff 1f       	adc	r31, r31
 4d2:	7a 95       	dec	r23
 4d4:	e1 f7       	brne	.-8      	; 0x4ce <draw_character+0x50>
 4d6:	e0 5c       	subi	r30, 0xC0	; 192
 4d8:	fe 4f       	sbci	r31, 0xFE	; 254
		startrow = 0;

	}


    characterptr += startrow;
 4da:	99 27       	eor	r25, r25
 4dc:	87 fd       	sbrc	r24, 7
 4de:	90 95       	com	r25
 4e0:	e8 0f       	add	r30, r24
 4e2:	f9 1f       	adc	r31, r25
    
	for (uint8_t iy = y; iy < (8 - startrow - y); iy++) 
 4e4:	16 2f       	mov	r17, r22
 4e6:	28 e0       	ldi	r18, 0x08	; 8
 4e8:	30 e0       	ldi	r19, 0x00	; 0
 4ea:	b9 01       	movw	r22, r18
 4ec:	68 1b       	sub	r22, r24
 4ee:	79 0b       	sbc	r23, r25
 4f0:	81 2f       	mov	r24, r17
 4f2:	99 27       	eor	r25, r25
 4f4:	87 fd       	sbrc	r24, 7
 4f6:	90 95       	com	r25
 4f8:	68 1b       	sub	r22, r24
 4fa:	79 0b       	sbc	r23, r25
	{
		// pointBuffer[iy] = 0;

		int8_t dotctr = startcol;

		for (uint8_t ix = x; ix < (8 - startcol); ix++)
 4fc:	e5 2e       	mov	r14, r21
 4fe:	ff 24       	eor	r15, r15
 500:	e7 fc       	sbrc	r14, 7
 502:	f0 94       	com	r15
 504:	69 01       	movw	r12, r18
 506:	ce 18       	sub	r12, r14
 508:	df 08       	sbc	r13, r15
		{
			
			if (*characterptr & (1 << dotctr)) pointBuffer[iy] |= (1 << ix); 
 50a:	41 e0       	ldi	r20, 0x01	; 1
 50c:	a4 2e       	mov	r10, r20
 50e:	b1 2c       	mov	r11, r1
 510:	26 c0       	rjmp	.+76     	; 0x55e <draw_character+0xe0>
	{
		// pointBuffer[iy] = 0;

		int8_t dotctr = startcol;

		for (uint8_t ix = x; ix < (8 - startcol); ix++)
 512:	40 e0       	ldi	r20, 0x00	; 0
 514:	50 e0       	ldi	r21, 0x00	; 0
		{
			
			if (*characterptr & (1 << dotctr)) pointBuffer[iy] |= (1 << ix); 
 516:	ec 01       	movw	r28, r24
 518:	c5 57       	subi	r28, 0x75	; 117
 51a:	d6 4f       	sbci	r29, 0xF6	; 246
 51c:	17 c0       	rjmp	.+46     	; 0x54c <draw_character+0xce>
 51e:	80 81       	ld	r24, Z
 520:	90 e0       	ldi	r25, 0x00	; 0
 522:	9a 01       	movw	r18, r20
 524:	2e 0d       	add	r18, r14
 526:	3f 1d       	adc	r19, r15
 528:	02 c0       	rjmp	.+4      	; 0x52e <draw_character+0xb0>
 52a:	95 95       	asr	r25
 52c:	87 95       	ror	r24
 52e:	2a 95       	dec	r18
 530:	e2 f7       	brpl	.-8      	; 0x52a <draw_character+0xac>
 532:	80 ff       	sbrs	r24, 0
 534:	09 c0       	rjmp	.+18     	; 0x548 <draw_character+0xca>
 536:	95 01       	movw	r18, r10
 538:	02 c0       	rjmp	.+4      	; 0x53e <draw_character+0xc0>
 53a:	22 0f       	add	r18, r18
 53c:	33 1f       	adc	r19, r19
 53e:	aa 95       	dec	r26
 540:	e2 f7       	brpl	.-8      	; 0x53a <draw_character+0xbc>
 542:	88 81       	ld	r24, Y
 544:	82 2b       	or	r24, r18
 546:	88 83       	st	Y, r24
 548:	4f 5f       	subi	r20, 0xFF	; 255
 54a:	5f 4f       	sbci	r21, 0xFF	; 255
	{
		// pointBuffer[iy] = 0;

		int8_t dotctr = startcol;

		for (uint8_t ix = x; ix < (8 - startcol); ix++)
 54c:	80 2f       	mov	r24, r16
 54e:	84 0f       	add	r24, r20
 550:	a8 2f       	mov	r26, r24
 552:	b0 e0       	ldi	r27, 0x00	; 0
 554:	ac 15       	cp	r26, r12
 556:	bd 05       	cpc	r27, r13
 558:	14 f3       	brlt	.-60     	; 0x51e <draw_character+0xa0>

			dotctr++;

		}

		characterptr += 1;
 55a:	31 96       	adiw	r30, 0x01	; 1
	}


    characterptr += startrow;
    
	for (uint8_t iy = y; iy < (8 - startrow - y); iy++) 
 55c:	1f 5f       	subi	r17, 0xFF	; 255
 55e:	81 2f       	mov	r24, r17
 560:	90 e0       	ldi	r25, 0x00	; 0
 562:	86 17       	cp	r24, r22
 564:	97 07       	cpc	r25, r23
 566:	ac f2       	brlt	.-86     	; 0x512 <draw_character+0x94>
		}

		characterptr += 1;

	}
}
 568:	df 91       	pop	r29
 56a:	cf 91       	pop	r28
 56c:	1f 91       	pop	r17
 56e:	0f 91       	pop	r16
 570:	ff 90       	pop	r15
 572:	ef 90       	pop	r14
 574:	df 90       	pop	r13
 576:	cf 90       	pop	r12
 578:	bf 90       	pop	r11
 57a:	af 90       	pop	r10
 57c:	08 95       	ret

0000057e <draw_line_v>:

void draw_line_v(uint8_t x, uint8_t r, uint8_t g, uint8_t b)
{
 57e:	90 e0       	ldi	r25, 0x00	; 0
	for (uint8_t y = 0; y < 8; y++) 
	{

		uint8_t index = (y * 8) + x;

		red_frame[index] = r;
 580:	e9 2f       	mov	r30, r25
 582:	e8 0f       	add	r30, r24
 584:	f0 e0       	ldi	r31, 0x00	; 0
 586:	df 01       	movw	r26, r30
 588:	a5 5b       	subi	r26, 0xB5	; 181
 58a:	b6 4f       	sbci	r27, 0xF6	; 246
 58c:	6c 93       	st	X, r22
		green_frame[index] = g;
 58e:	df 01       	movw	r26, r30
 590:	a8 5a       	subi	r26, 0xA8	; 168
 592:	b5 4f       	sbci	r27, 0xF5	; 245
 594:	4c 93       	st	X, r20
		blue_frame[index] = b;
 596:	e8 5e       	subi	r30, 0xE8	; 232
 598:	f5 4f       	sbci	r31, 0xF5	; 245
 59a:	20 83       	st	Z, r18
 59c:	98 5f       	subi	r25, 0xF8	; 248
	}
}

void draw_line_v(uint8_t x, uint8_t r, uint8_t g, uint8_t b)
{
	for (uint8_t y = 0; y < 8; y++) 
 59e:	90 34       	cpi	r25, 0x40	; 64
 5a0:	79 f7       	brne	.-34     	; 0x580 <draw_line_v+0x2>
		green_frame[index] = g;
		blue_frame[index] = b;

	}

}
 5a2:	08 95       	ret

000005a4 <draw_line_h>:
{

	for (int x = 0; x < 8; x++) 
	{

		uint8_t index = (y * 8) + x;
 5a4:	38 2f       	mov	r19, r24
 5a6:	33 0f       	add	r19, r19
 5a8:	33 0f       	add	r19, r19
 5aa:	33 0f       	add	r19, r19
 5ac:	80 e0       	ldi	r24, 0x00	; 0
 5ae:	90 e0       	ldi	r25, 0x00	; 0

		red_frame[index] = r;
 5b0:	e3 2f       	mov	r30, r19
 5b2:	e8 0f       	add	r30, r24
 5b4:	f0 e0       	ldi	r31, 0x00	; 0
 5b6:	df 01       	movw	r26, r30
 5b8:	a5 5b       	subi	r26, 0xB5	; 181
 5ba:	b6 4f       	sbci	r27, 0xF6	; 246
 5bc:	6c 93       	st	X, r22
		green_frame[index] = g;
 5be:	df 01       	movw	r26, r30
 5c0:	a8 5a       	subi	r26, 0xA8	; 168
 5c2:	b5 4f       	sbci	r27, 0xF5	; 245
 5c4:	4c 93       	st	X, r20
		blue_frame[index] = b;
 5c6:	e8 5e       	subi	r30, 0xE8	; 232
 5c8:	f5 4f       	sbci	r31, 0xF5	; 245
 5ca:	20 83       	st	Z, r18


void draw_line_h(uint8_t y, uint8_t r, uint8_t g, uint8_t b)
{

	for (int x = 0; x < 8; x++) 
 5cc:	01 96       	adiw	r24, 0x01	; 1
 5ce:	88 30       	cpi	r24, 0x08	; 8
 5d0:	91 05       	cpc	r25, r1
 5d2:	71 f7       	brne	.-36     	; 0x5b0 <draw_line_h+0xc>
		green_frame[index] = g;
		blue_frame[index] = b;

	}

}
 5d4:	08 95       	ret

000005d6 <set_all>:
}



void set_all(uint8_t r, uint8_t g, uint8_t b)
{
 5d6:	20 e0       	ldi	r18, 0x00	; 0
 5d8:	30 e0       	ldi	r19, 0x00	; 0

	uint16_t i;

	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = r;
 5da:	f9 01       	movw	r30, r18
 5dc:	e5 5b       	subi	r30, 0xB5	; 181
 5de:	f6 4f       	sbci	r31, 0xF6	; 246
 5e0:	80 83       	st	Z, r24
		green_frame[i] = g;
 5e2:	f9 01       	movw	r30, r18
 5e4:	e8 5a       	subi	r30, 0xA8	; 168
 5e6:	f5 4f       	sbci	r31, 0xF5	; 245
 5e8:	60 83       	st	Z, r22
		blue_frame[i] = b;
 5ea:	f9 01       	movw	r30, r18
 5ec:	e8 5e       	subi	r30, 0xE8	; 232
 5ee:	f5 4f       	sbci	r31, 0xF5	; 245
 5f0:	40 83       	st	Z, r20
void set_all(uint8_t r, uint8_t g, uint8_t b)
{

	uint16_t i;

	for(i = 0 ; i < 64 ; i++)
 5f2:	2f 5f       	subi	r18, 0xFF	; 255
 5f4:	3f 4f       	sbci	r19, 0xFF	; 255
 5f6:	20 34       	cpi	r18, 0x40	; 64
 5f8:	31 05       	cpc	r19, r1
 5fa:	79 f7       	brne	.-34     	; 0x5da <set_all+0x4>
		red_frame[i] = r;
		green_frame[i] = g;
		blue_frame[i] = b;
	}
	
}
 5fc:	08 95       	ret

000005fe <parse_frame332>:
Purpose:	Parses the red, green and blue values out of the temporary frame buffer and into separate color buffers
Parameters:	None. Uses global buffer[] and copies data to global red_frame[], green_frame[] and blue_frame[]
Return:		None.
*/
void parse_frame332(void)
{
 5fe:	40 e0       	ldi	r20, 0x00	; 0
 600:	50 e0       	ldi	r21, 0x00	; 0
 602:	6f e3       	ldi	r22, 0x3F	; 63
 604:	70 e0       	ldi	r23, 0x00	; 0
 606:	fb 01       	movw	r30, r22
 608:	e4 1b       	sub	r30, r20
 60a:	f5 0b       	sbc	r31, r21
    uint8_t color_value;
    
    for(int LED = 0 ; LED < 64 ; LED++)
    {
        color_value = buffer[63-LED];
 60c:	ed 56       	subi	r30, 0x6D	; 109
 60e:	f6 4f       	sbci	r31, 0xF6	; 246
 610:	20 81       	ld	r18, Z
        red_frame[LED] = (color_value & 0xE0) >> 5;	//(temp & 0b11100000) >> 5; Highes 3 bits represent the Red value for the current LED
 612:	82 2f       	mov	r24, r18
 614:	82 95       	swap	r24
 616:	86 95       	lsr	r24
 618:	87 70       	andi	r24, 0x07	; 7
 61a:	fa 01       	movw	r30, r20
 61c:	e5 5b       	subi	r30, 0xB5	; 181
 61e:	f6 4f       	sbci	r31, 0xF6	; 246
 620:	80 83       	st	Z, r24
        green_frame[LED] = (color_value & 0x1C) >> 2; 	//(temp & 0b00011100) >> 2; Next 3 bits represent the Green value for the current LED
 622:	82 2f       	mov	r24, r18
 624:	90 e0       	ldi	r25, 0x00	; 0
 626:	8c 71       	andi	r24, 0x1C	; 28
 628:	90 70       	andi	r25, 0x00	; 0
 62a:	95 95       	asr	r25
 62c:	87 95       	ror	r24
 62e:	95 95       	asr	r25
 630:	87 95       	ror	r24
 632:	fa 01       	movw	r30, r20
 634:	e8 5a       	subi	r30, 0xA8	; 168
 636:	f5 4f       	sbci	r31, 0xF5	; 245
 638:	80 83       	st	Z, r24
        blue_frame[LED] = (color_value & 0x03); 		//(temp & 0b00000011); Final 2 bits represent the Blue value for the current LED
 63a:	23 70       	andi	r18, 0x03	; 3
 63c:	fa 01       	movw	r30, r20
 63e:	e8 5e       	subi	r30, 0xE8	; 232
 640:	f5 4f       	sbci	r31, 0xF5	; 245
 642:	20 83       	st	Z, r18
*/
void parse_frame332(void)
{
    uint8_t color_value;
    
    for(int LED = 0 ; LED < 64 ; LED++)
 644:	4f 5f       	subi	r20, 0xFF	; 255
 646:	5f 4f       	sbci	r21, 0xFF	; 255
 648:	40 34       	cpi	r20, 0x40	; 64
 64a:	51 05       	cpc	r21, r1
 64c:	e1 f6       	brne	.-72     	; 0x606 <parse_frame332+0x8>
        color_value = buffer[63-LED];
        red_frame[LED] = (color_value & 0xE0) >> 5;	//(temp & 0b11100000) >> 5; Highes 3 bits represent the Red value for the current LED
        green_frame[LED] = (color_value & 0x1C) >> 2; 	//(temp & 0b00011100) >> 2; Next 3 bits represent the Green value for the current LED
        blue_frame[LED] = (color_value & 0x03); 		//(temp & 0b00000011); Final 2 bits represent the Blue value for the current LED
    }
    new_frame = 0; //Reset new frame flag
 64e:	10 92 98 0a 	sts	0x0A98, r1
}
 652:	08 95       	ret

00000654 <parse_frame555>:

void parse_frame555(void)
{
 654:	60 e0       	ldi	r22, 0x00	; 0
 656:	70 e0       	ldi	r23, 0x00	; 0
    uint8_t color_value1;
	uint8_t color_value2;
    
    for(int LED = 0 ; LED < 64 ; LED++)
    {
        color_value1 = buffer[(LED << 1)];
 658:	fb 01       	movw	r30, r22
 65a:	ee 0f       	add	r30, r30
 65c:	ff 1f       	adc	r31, r31
 65e:	df 01       	movw	r26, r30
 660:	ad 56       	subi	r26, 0x6D	; 109
 662:	b6 4f       	sbci	r27, 0xF6	; 246
 664:	4c 91       	ld	r20, X
		color_value2 = buffer[(LED << 1)+1];
 666:	ec 56       	subi	r30, 0x6C	; 108
 668:	f6 4f       	sbci	r31, 0xF6	; 246
 66a:	20 81       	ld	r18, Z

		//(temp1 & 0b00011111) >> 0
        red_frame[LED]   = ((color_value1 & 0x1F) >> 0);	
 66c:	84 2f       	mov	r24, r20
 66e:	8f 71       	andi	r24, 0x1F	; 31
 670:	fb 01       	movw	r30, r22
 672:	e5 5b       	subi	r30, 0xB5	; 181
 674:	f6 4f       	sbci	r31, 0xF6	; 246
 676:	80 83       	st	Z, r24

		//(temp1 & 0b11100000) >> 5 | (temp2 & 0b00000011) << 3
        green_frame[LED] = ((color_value1 & 0xE0) >> 5) | ((color_value2 & 0x3) << 3); 	
 678:	30 e0       	ldi	r19, 0x00	; 0
 67a:	c9 01       	movw	r24, r18
 67c:	83 70       	andi	r24, 0x03	; 3
 67e:	90 70       	andi	r25, 0x00	; 0
 680:	a3 e0       	ldi	r26, 0x03	; 3
 682:	88 0f       	add	r24, r24
 684:	99 1f       	adc	r25, r25
 686:	aa 95       	dec	r26
 688:	e1 f7       	brne	.-8      	; 0x682 <parse_frame555+0x2e>
 68a:	42 95       	swap	r20
 68c:	46 95       	lsr	r20
 68e:	47 70       	andi	r20, 0x07	; 7
 690:	48 2b       	or	r20, r24
 692:	fb 01       	movw	r30, r22
 694:	e8 5a       	subi	r30, 0xA8	; 168
 696:	f5 4f       	sbci	r31, 0xF5	; 245
 698:	40 83       	st	Z, r20

		// (temp2 & 0b01111100) >> 2
        blue_frame[LED]  = ((color_value2 & 0x7C) >> 2); 		
 69a:	2c 77       	andi	r18, 0x7C	; 124
 69c:	30 70       	andi	r19, 0x00	; 0
 69e:	35 95       	asr	r19
 6a0:	27 95       	ror	r18
 6a2:	35 95       	asr	r19
 6a4:	27 95       	ror	r18
 6a6:	fb 01       	movw	r30, r22
 6a8:	e8 5e       	subi	r30, 0xE8	; 232
 6aa:	f5 4f       	sbci	r31, 0xF5	; 245
 6ac:	20 83       	st	Z, r18
void parse_frame555(void)
{
    uint8_t color_value1;
	uint8_t color_value2;
    
    for(int LED = 0 ; LED < 64 ; LED++)
 6ae:	6f 5f       	subi	r22, 0xFF	; 255
 6b0:	7f 4f       	sbci	r23, 0xFF	; 255
 6b2:	60 34       	cpi	r22, 0x40	; 64
 6b4:	71 05       	cpc	r23, r1
 6b6:	81 f6       	brne	.-96     	; 0x658 <parse_frame555+0x4>
        green_frame[LED] = ((color_value1 & 0xE0) >> 5) | ((color_value2 & 0x3) << 3); 	

		// (temp2 & 0b01111100) >> 2
        blue_frame[LED]  = ((color_value2 & 0x7C) >> 2); 		
    }
    new_frame = 0; //Reset new frame flag
 6b8:	10 92 98 0a 	sts	0x0A98, r1
}
 6bc:	08 95       	ret

000006be <shift_out_line>:
Purpose:	Sends a single row of colors to the RGB matrix.
Parameters:	input row_num - Designates which row will be sent to the matrix
Return:		None
*/
void shift_out_line(volatile uint8_t row_num)
{
 6be:	df 93       	push	r29
 6c0:	cf 93       	push	r28
 6c2:	0f 92       	push	r0
 6c4:	cd b7       	in	r28, 0x3d	; 61
 6c6:	de b7       	in	r29, 0x3e	; 62
 6c8:	89 83       	std	Y+1, r24	; 0x01
	cbi(PORTC, LATCH);	//Disable the shift registers
 6ca:	42 98       	cbi	0x08, 2	; 8

	uint8_t lineStart = row_num << 3;
 6cc:	89 81       	ldd	r24, Y+1	; 0x01
    uint8_t lineEnd = lineStart + 8;
 6ce:	88 0f       	add	r24, r24
 6d0:	88 0f       	add	r24, r24
 6d2:	88 0f       	add	r24, r24
 6d4:	88 5f       	subi	r24, 0xF8	; 248
 6d6:	20 e0       	ldi	r18, 0x00	; 0
 6d8:	30 e0       	ldi	r19, 0x00	; 0
Purpose:	Sends a single row of colors to the RGB matrix.
Parameters:	input row_num - Designates which row will be sent to the matrix
Return:		None
*/
void shift_out_line(volatile uint8_t row_num)
{
 6da:	48 2f       	mov	r20, r24
 6dc:	50 e0       	ldi	r21, 0x00	; 0
 6de:	41 50       	subi	r20, 0x01	; 1
 6e0:	50 40       	sbci	r21, 0x00	; 0
	//Send Red Values
	//for(uint8_t LED = lineStart ; LED < lineEnd ; LED++) //Step through bits
	//for(uint8_t LED = (lineEnd - 1) ; LED >= lineStart ; LED--) //Step through bits
	for(uint8_t LED = 1 ; LED < 9 ; LED++) //Step through bits
	{
		cbi(PORTC, CLK);	//Lower the shift register clock so we can configure the data
 6e2:	40 98       	cbi	0x08, 0	; 8
		
		//Compare the current color value to timer_clicks to Pulse Width Modulate the LED to create the designated brightness
		if(timer_clicks < red_frame[lineEnd - LED])
 6e4:	80 91 43 09 	lds	r24, 0x0943
Purpose:	Sends a single row of colors to the RGB matrix.
Parameters:	input row_num - Designates which row will be sent to the matrix
Return:		None
*/
void shift_out_line(volatile uint8_t row_num)
{
 6e8:	fa 01       	movw	r30, r20
 6ea:	e2 1b       	sub	r30, r18
 6ec:	f3 0b       	sbc	r31, r19
	for(uint8_t LED = 1 ; LED < 9 ; LED++) //Step through bits
	{
		cbi(PORTC, CLK);	//Lower the shift register clock so we can configure the data
		
		//Compare the current color value to timer_clicks to Pulse Width Modulate the LED to create the designated brightness
		if(timer_clicks < red_frame[lineEnd - LED])
 6ee:	e5 5b       	subi	r30, 0xB5	; 181
 6f0:	f6 4f       	sbci	r31, 0xF6	; 246
 6f2:	90 81       	ld	r25, Z
 6f4:	89 17       	cp	r24, r25
 6f6:	10 f4       	brcc	.+4      	; 0x6fc <shift_out_line+0x3e>
			sbi(PORTC, DATA);
 6f8:	41 9a       	sbi	0x08, 1	; 8
 6fa:	01 c0       	rjmp	.+2      	; 0x6fe <shift_out_line+0x40>
		else
			cbi(PORTC, DATA);
 6fc:	41 98       	cbi	0x08, 1	; 8

		sbi(PORTC, CLK);	//Raise the shift register clock to lock in the data
 6fe:	40 9a       	sbi	0x08, 0	; 8
 700:	2f 5f       	subi	r18, 0xFF	; 255
 702:	3f 4f       	sbci	r19, 0xFF	; 255
    uint8_t lineEnd = lineStart + 8;

	//Send Red Values
	//for(uint8_t LED = lineStart ; LED < lineEnd ; LED++) //Step through bits
	//for(uint8_t LED = (lineEnd - 1) ; LED >= lineStart ; LED--) //Step through bits
	for(uint8_t LED = 1 ; LED < 9 ; LED++) //Step through bits
 704:	28 30       	cpi	r18, 0x08	; 8
 706:	31 05       	cpc	r19, r1
 708:	61 f7       	brne	.-40     	; 0x6e2 <shift_out_line+0x24>
 70a:	20 e0       	ldi	r18, 0x00	; 0
 70c:	30 e0       	ldi	r19, 0x00	; 0

	//Send Blue Values
	//for(uint8_t LED = lineStart ; LED < lineEnd ; LED++) //Step through bits
	for(uint8_t LED = 1 ; LED < 9 ; LED++) //Step through bits
	{
		cbi(PORTC, CLK);	//Lower the shift register clock so we can configure the data
 70e:	40 98       	cbi	0x08, 0	; 8
	
		//Compare the current color value to timer_clicks to Pulse Width Modulate the LED to create the designated brightness
		if(timer_clicks < blue_frame[lineEnd - LED])
 710:	80 91 43 09 	lds	r24, 0x0943
 714:	fa 01       	movw	r30, r20
 716:	e2 1b       	sub	r30, r18
 718:	f3 0b       	sbc	r31, r19
 71a:	e8 5e       	subi	r30, 0xE8	; 232
 71c:	f5 4f       	sbci	r31, 0xF5	; 245
 71e:	90 81       	ld	r25, Z
 720:	89 17       	cp	r24, r25
 722:	10 f4       	brcc	.+4      	; 0x728 <shift_out_line+0x6a>
			sbi(PORTC, DATA);
 724:	41 9a       	sbi	0x08, 1	; 8
 726:	01 c0       	rjmp	.+2      	; 0x72a <shift_out_line+0x6c>
		else
			cbi(PORTC, DATA);
 728:	41 98       	cbi	0x08, 1	; 8

		sbi(PORTC, CLK);	//Raise the shift register clock to lock in the data
 72a:	40 9a       	sbi	0x08, 0	; 8
 72c:	2f 5f       	subi	r18, 0xFF	; 255
 72e:	3f 4f       	sbci	r19, 0xFF	; 255
		sbi(PORTC, CLK);	//Raise the shift register clock to lock in the data
	}

	//Send Blue Values
	//for(uint8_t LED = lineStart ; LED < lineEnd ; LED++) //Step through bits
	for(uint8_t LED = 1 ; LED < 9 ; LED++) //Step through bits
 730:	28 30       	cpi	r18, 0x08	; 8
 732:	31 05       	cpc	r19, r1
 734:	61 f7       	brne	.-40     	; 0x70e <shift_out_line+0x50>
 736:	20 e0       	ldi	r18, 0x00	; 0
 738:	30 e0       	ldi	r19, 0x00	; 0

	//Send Green Values
	//for(uint8_t LED = lineStart ; LED < lineEnd ; LED++) //Step through bits
	for(uint8_t LED = 1 ; LED < 9 ; LED++) //Step through bits
	{
		cbi(PORTC, CLK);	//Lower the shift register clock so we can configure the data
 73a:	40 98       	cbi	0x08, 0	; 8
	
		//Compare the current color value to timer_clicks to Pulse Width Modulate the LED to create the designated brightness
		if(timer_clicks < green_frame[lineEnd - LED])
 73c:	80 91 43 09 	lds	r24, 0x0943
 740:	fa 01       	movw	r30, r20
 742:	e2 1b       	sub	r30, r18
 744:	f3 0b       	sbc	r31, r19
 746:	e8 5a       	subi	r30, 0xA8	; 168
 748:	f5 4f       	sbci	r31, 0xF5	; 245
 74a:	90 81       	ld	r25, Z
 74c:	89 17       	cp	r24, r25
 74e:	10 f4       	brcc	.+4      	; 0x754 <shift_out_line+0x96>
			sbi(PORTC, DATA);
 750:	41 9a       	sbi	0x08, 1	; 8
 752:	01 c0       	rjmp	.+2      	; 0x756 <shift_out_line+0x98>
		else
			cbi(PORTC, DATA);
 754:	41 98       	cbi	0x08, 1	; 8

		sbi(PORTC, CLK);	//Raise the shift register clock to lock in the data
 756:	40 9a       	sbi	0x08, 0	; 8
 758:	2f 5f       	subi	r18, 0xFF	; 255
 75a:	3f 4f       	sbci	r19, 0xFF	; 255
		sbi(PORTC, CLK);	//Raise the shift register clock to lock in the data
	}

	//Send Green Values
	//for(uint8_t LED = lineStart ; LED < lineEnd ; LED++) //Step through bits
	for(uint8_t LED = 1 ; LED < 9 ; LED++) //Step through bits
 75c:	28 30       	cpi	r18, 0x08	; 8
 75e:	31 05       	cpc	r19, r1
 760:	61 f7       	brne	.-40     	; 0x73a <shift_out_line+0x7c>
			cbi(PORTC, DATA);

		sbi(PORTC, CLK);	//Raise the shift register clock to lock in the data
	}

	sbi(PORTC, EN);		//Disable the Shift Register Outputs
 762:	44 9a       	sbi	0x08, 4	; 8
	sbi(PORTC, LATCH);	//Put the new data onto the outputs of the shift register
 764:	42 9a       	sbi	0x08, 2	; 8

	PORTD = (1<<row_num); //Sink current through row (Turns colors 'ON' for the given row. Keep in mind that we can only display to 1 row at a time.)
 766:	29 81       	ldd	r18, Y+1	; 0x01
 768:	81 e0       	ldi	r24, 0x01	; 1
 76a:	90 e0       	ldi	r25, 0x00	; 0
 76c:	02 c0       	rjmp	.+4      	; 0x772 <shift_out_line+0xb4>
 76e:	88 0f       	add	r24, r24
 770:	99 1f       	adc	r25, r25
 772:	2a 95       	dec	r18
 774:	e2 f7       	brpl	.-8      	; 0x76e <shift_out_line+0xb0>
 776:	8b b9       	out	0x0b, r24	; 11

	cbi(PORTC, EN);		//Enable the Shift Register Outputs
 778:	44 98       	cbi	0x08, 4	; 8
}
 77a:	0f 90       	pop	r0
 77c:	cf 91       	pop	r28
 77e:	df 91       	pop	r29
 780:	08 95       	ret

00000782 <post_frames>:
Purpose:	Puts the current image located in the red_frame, green_frame and blue_frame buffers onto the RGB matrix
Parameters:	None
Return:		None
*/
void post_frames(void)
{	
 782:	1f 93       	push	r17
 784:	10 e0       	ldi	r17, 0x00	; 0
	for(char row = 0 ; row < 8; row++)shift_out_line(row);	//Send all 8 rows of colors to the Matrix
 786:	81 2f       	mov	r24, r17
 788:	0e 94 5f 03 	call	0x6be	; 0x6be <shift_out_line>
 78c:	1f 5f       	subi	r17, 0xFF	; 255
 78e:	18 30       	cpi	r17, 0x08	; 8
 790:	d1 f7       	brne	.-12     	; 0x786 <post_frames+0x4>
}
 792:	1f 91       	pop	r17
 794:	08 95       	ret

00000796 <splash_screen>:
Purpose:	Tests all of the LEDs. Function will cause matrix to go all Red for 300ms, then all Green for 300ms, then all Blue for 300ms, then display a "smiley"
Parameters:	None
Return:		None
*/
void splash_screen(void)
{
 796:	cf 93       	push	r28
 798:	df 93       	push	r29
	uint16_t i;
	cli();
 79a:	f8 94       	cli
 79c:	80 e0       	ldi	r24, 0x00	; 0
 79e:	90 e0       	ldi	r25, 0x00	; 0
	//Fill red
	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = 7;
 7a0:	27 e0       	ldi	r18, 0x07	; 7
 7a2:	fc 01       	movw	r30, r24
 7a4:	e5 5b       	subi	r30, 0xB5	; 181
 7a6:	f6 4f       	sbci	r31, 0xF6	; 246
 7a8:	20 83       	st	Z, r18
		green_frame[i] = 0;
 7aa:	fc 01       	movw	r30, r24
 7ac:	e8 5a       	subi	r30, 0xA8	; 168
 7ae:	f5 4f       	sbci	r31, 0xF5	; 245
 7b0:	10 82       	st	Z, r1
		blue_frame[i] = 0;
 7b2:	fc 01       	movw	r30, r24
 7b4:	e8 5e       	subi	r30, 0xE8	; 232
 7b6:	f5 4f       	sbci	r31, 0xF5	; 245
 7b8:	10 82       	st	Z, r1
void splash_screen(void)
{
	uint16_t i;
	cli();
	//Fill red
	for(i = 0 ; i < 64 ; i++)
 7ba:	01 96       	adiw	r24, 0x01	; 1
 7bc:	80 34       	cpi	r24, 0x40	; 64
 7be:	91 05       	cpc	r25, r1
 7c0:	81 f7       	brne	.-32     	; 0x7a2 <splash_screen+0xc>
 7c2:	c0 e0       	ldi	r28, 0x00	; 0
 7c4:	d0 e0       	ldi	r29, 0x00	; 0
		green_frame[i] = 0;
		blue_frame[i] = 0;
	}

	for(i = 0 ; i < 1000 ; i++)
		post_frames();
 7c6:	0e 94 c1 03 	call	0x782	; 0x782 <post_frames>
		red_frame[i] = 7;
		green_frame[i] = 0;
		blue_frame[i] = 0;
	}

	for(i = 0 ; i < 1000 ; i++)
 7ca:	21 96       	adiw	r28, 0x01	; 1
 7cc:	83 e0       	ldi	r24, 0x03	; 3
 7ce:	c8 3e       	cpi	r28, 0xE8	; 232
 7d0:	d8 07       	cpc	r29, r24
 7d2:	c9 f7       	brne	.-14     	; 0x7c6 <splash_screen+0x30>
 7d4:	80 e0       	ldi	r24, 0x00	; 0
 7d6:	90 e0       	ldi	r25, 0x00	; 0

	//Fill green
	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = 0;
		green_frame[i] = 7;
 7d8:	27 e0       	ldi	r18, 0x07	; 7
		post_frames();

	//Fill green
	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = 0;
 7da:	fc 01       	movw	r30, r24
 7dc:	e5 5b       	subi	r30, 0xB5	; 181
 7de:	f6 4f       	sbci	r31, 0xF6	; 246
 7e0:	10 82       	st	Z, r1
		green_frame[i] = 7;
 7e2:	fc 01       	movw	r30, r24
 7e4:	e8 5a       	subi	r30, 0xA8	; 168
 7e6:	f5 4f       	sbci	r31, 0xF5	; 245
 7e8:	20 83       	st	Z, r18
		blue_frame[i] = 0;
 7ea:	fc 01       	movw	r30, r24
 7ec:	e8 5e       	subi	r30, 0xE8	; 232
 7ee:	f5 4f       	sbci	r31, 0xF5	; 245
 7f0:	10 82       	st	Z, r1

	for(i = 0 ; i < 1000 ; i++)
		post_frames();

	//Fill green
	for(i = 0 ; i < 64 ; i++)
 7f2:	01 96       	adiw	r24, 0x01	; 1
 7f4:	80 34       	cpi	r24, 0x40	; 64
 7f6:	91 05       	cpc	r25, r1
 7f8:	81 f7       	brne	.-32     	; 0x7da <splash_screen+0x44>
 7fa:	c0 e0       	ldi	r28, 0x00	; 0
 7fc:	d0 e0       	ldi	r29, 0x00	; 0
		green_frame[i] = 7;
		blue_frame[i] = 0;
	}

	for(i = 0 ; i < 1000 ; i++)
		post_frames();
 7fe:	0e 94 c1 03 	call	0x782	; 0x782 <post_frames>
		red_frame[i] = 0;
		green_frame[i] = 7;
		blue_frame[i] = 0;
	}

	for(i = 0 ; i < 1000 ; i++)
 802:	21 96       	adiw	r28, 0x01	; 1
 804:	83 e0       	ldi	r24, 0x03	; 3
 806:	c8 3e       	cpi	r28, 0xE8	; 232
 808:	d8 07       	cpc	r29, r24
 80a:	c9 f7       	brne	.-14     	; 0x7fe <splash_screen+0x68>
 80c:	80 e0       	ldi	r24, 0x00	; 0
 80e:	90 e0       	ldi	r25, 0x00	; 0
	//Fill blue
	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = 0;
		green_frame[i] = 0;
		blue_frame[i] = 7;
 810:	27 e0       	ldi	r18, 0x07	; 7
		post_frames();

	//Fill blue
	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = 0;
 812:	fc 01       	movw	r30, r24
 814:	e5 5b       	subi	r30, 0xB5	; 181
 816:	f6 4f       	sbci	r31, 0xF6	; 246
 818:	10 82       	st	Z, r1
		green_frame[i] = 0;
 81a:	fc 01       	movw	r30, r24
 81c:	e8 5a       	subi	r30, 0xA8	; 168
 81e:	f5 4f       	sbci	r31, 0xF5	; 245
 820:	10 82       	st	Z, r1
		blue_frame[i] = 7;
 822:	fc 01       	movw	r30, r24
 824:	e8 5e       	subi	r30, 0xE8	; 232
 826:	f5 4f       	sbci	r31, 0xF5	; 245
 828:	20 83       	st	Z, r18

	for(i = 0 ; i < 1000 ; i++)
		post_frames();

	//Fill blue
	for(i = 0 ; i < 64 ; i++)
 82a:	01 96       	adiw	r24, 0x01	; 1
 82c:	80 34       	cpi	r24, 0x40	; 64
 82e:	91 05       	cpc	r25, r1
 830:	81 f7       	brne	.-32     	; 0x812 <splash_screen+0x7c>
 832:	c0 e0       	ldi	r28, 0x00	; 0
 834:	d0 e0       	ldi	r29, 0x00	; 0
		green_frame[i] = 0;
		blue_frame[i] = 7;
	}

	for(i = 0 ; i < 1000 ; i++)
		 post_frames(); 
 836:	0e 94 c1 03 	call	0x782	; 0x782 <post_frames>
		red_frame[i] = 0;
		green_frame[i] = 0;
		blue_frame[i] = 7;
	}

	for(i = 0 ; i < 1000 ; i++)
 83a:	21 96       	adiw	r28, 0x01	; 1
 83c:	83 e0       	ldi	r24, 0x03	; 3
 83e:	c8 3e       	cpi	r28, 0xE8	; 232
 840:	d8 07       	cpc	r29, r24
 842:	c9 f7       	brne	.-14     	; 0x836 <splash_screen+0xa0>
 844:	80 e0       	ldi	r24, 0x00	; 0
 846:	90 e0       	ldi	r25, 0x00	; 0
	*/

	//Erase frame data
	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = 0;
 848:	fc 01       	movw	r30, r24
 84a:	e5 5b       	subi	r30, 0xB5	; 181
 84c:	f6 4f       	sbci	r31, 0xF6	; 246
 84e:	10 82       	st	Z, r1
		green_frame[i] = 0;
 850:	fc 01       	movw	r30, r24
 852:	e8 5a       	subi	r30, 0xA8	; 168
 854:	f5 4f       	sbci	r31, 0xF5	; 245
 856:	10 82       	st	Z, r1
		blue_frame[i] = 0;
 858:	fc 01       	movw	r30, r24
 85a:	e8 5e       	subi	r30, 0xE8	; 232
 85c:	f5 4f       	sbci	r31, 0xF5	; 245
 85e:	10 82       	st	Z, r1
		 post_frames(); 		 

	*/

	//Erase frame data
	for(i = 0 ; i < 64 ; i++)
 860:	01 96       	adiw	r24, 0x01	; 1
 862:	80 34       	cpi	r24, 0x40	; 64
 864:	91 05       	cpc	r25, r1
 866:	81 f7       	brne	.-32     	; 0x848 <splash_screen+0xb2>
	{
		red_frame[i] = 0;
		green_frame[i] = 0;
		blue_frame[i] = 0;
	}
	sei();
 868:	78 94       	sei
	PORTD = 0; //Turn off display
 86a:	1b b8       	out	0x0b, r1	; 11
}
 86c:	df 91       	pop	r29
 86e:	cf 91       	pop	r28
 870:	08 95       	ret

00000872 <delay_us>:
Parameters:	input x - number of microseconds to delay
Return:		None
*/
void delay_us(uint8_t x)
{
	TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer2
 872:	91 e0       	ldi	r25, 0x01	; 1
 874:	95 bb       	out	0x15, r25	; 21
	TCNT0 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 876:	98 2f       	mov	r25, r24
 878:	91 95       	neg	r25
 87a:	96 bd       	out	0x26, r25	; 38
	while( (TIFR0 & (1<<TOV0)) == 0);
 87c:	a8 9b       	sbis	0x15, 0	; 21
 87e:	fe cf       	rjmp	.-4      	; 0x87c <delay_us+0xa>

	//Double the delay because we are using 16MHz and 8 prescalar

	TIFR0 = (1<<TOV0); //Clear any interrupt flags on Timer2
 880:	81 e0       	ldi	r24, 0x01	; 1
 882:	85 bb       	out	0x15, r24	; 21
	TCNT0 = 256 - x; //256 - 125 = 131 : Preload timer 2 for x clicks. Should be 1us per click
 884:	96 bd       	out	0x26, r25	; 38
	while( (TIFR0 & (1<<TOV0)) == 0);
 886:	a8 9b       	sbis	0x15, 0	; 21
 888:	fe cf       	rjmp	.-4      	; 0x886 <delay_us+0x14>
}
 88a:	08 95       	ret

0000088c <delay_ms>:
Purpose:	Delays the firmware for ~1ms
Parameters:	input x - number of ms to delay
Return:		None
*/
void delay_ms(uint16_t x)
{
 88c:	cf 93       	push	r28
 88e:	df 93       	push	r29
 890:	ec 01       	movw	r28, r24
 892:	0d c0       	rjmp	.+26     	; 0x8ae <delay_ms+0x22>
	for ( ; x > 0 ; x--)
	{
		delay_us(250);
 894:	8a ef       	ldi	r24, 0xFA	; 250
 896:	0e 94 39 04 	call	0x872	; 0x872 <delay_us>
		delay_us(250);
 89a:	8a ef       	ldi	r24, 0xFA	; 250
 89c:	0e 94 39 04 	call	0x872	; 0x872 <delay_us>
		delay_us(250);
 8a0:	8a ef       	ldi	r24, 0xFA	; 250
 8a2:	0e 94 39 04 	call	0x872	; 0x872 <delay_us>
		delay_us(250);
 8a6:	8a ef       	ldi	r24, 0xFA	; 250
 8a8:	0e 94 39 04 	call	0x872	; 0x872 <delay_us>
Parameters:	input x - number of ms to delay
Return:		None
*/
void delay_ms(uint16_t x)
{
	for ( ; x > 0 ; x--)
 8ac:	21 97       	sbiw	r28, 0x01	; 1
 8ae:	20 97       	sbiw	r28, 0x00	; 0
 8b0:	89 f7       	brne	.-30     	; 0x894 <delay_ms+0x8>
		delay_us(250);
		delay_us(250);
		delay_us(250);
		delay_us(250);
	}
}
 8b2:	df 91       	pop	r29
 8b4:	cf 91       	pop	r28
 8b6:	08 95       	ret

000008b8 <write_to_EEPROM>:
//Usage: write_to_EEPROM(0, 'A');
void write_to_EEPROM(unsigned int Address, unsigned char Data)
{
    //Interrupts are globally disabled!
	
	while(EECR & (1<<EEPE)); //Wait for last Write to complete
 8b8:	f9 99       	sbic	0x1f, 1	; 31
 8ba:	fe cf       	rjmp	.-4      	; 0x8b8 <write_to_EEPROM>
	//May need to wait for Flash to complete also!
	EEAR = Address;			//Assign the Address Register with "Address"
 8bc:	92 bd       	out	0x22, r25	; 34
 8be:	81 bd       	out	0x21, r24	; 33
	EEDR=Data;				//Put "Data" in the Data Register
 8c0:	60 bd       	out	0x20, r22	; 32
	EECR |= (1<<EEMPE); 	//Write to Master Write Enable
 8c2:	fa 9a       	sbi	0x1f, 2	; 31
	EECR |= (1<<EEPE);  	//Start Write by setting EE Write Enable
 8c4:	f9 9a       	sbi	0x1f, 1	; 31
	
}
 8c6:	08 95       	ret

000008c8 <process_command>:
Return:		None
*/
void process_command() 
{

	switch(current_subcommand) {
 8c8:	80 91 4a 09 	lds	r24, 0x094A
 8cc:	87 30       	cpi	r24, 0x07	; 7
 8ce:	09 f4       	brne	.+2      	; 0x8d2 <process_command+0xa>
 8d0:	81 c0       	rjmp	.+258    	; 0x9d4 <__stack+0xd5>
 8d2:	88 30       	cpi	r24, 0x08	; 8
 8d4:	98 f4       	brcc	.+38     	; 0x8fc <process_command+0x34>
 8d6:	83 30       	cpi	r24, 0x03	; 3
 8d8:	09 f4       	brne	.+2      	; 0x8dc <process_command+0x14>
 8da:	ca c0       	rjmp	.+404    	; 0xa70 <__stack+0x171>
 8dc:	84 30       	cpi	r24, 0x04	; 4
 8de:	38 f4       	brcc	.+14     	; 0x8ee <process_command+0x26>
 8e0:	81 30       	cpi	r24, 0x01	; 1
 8e2:	09 f4       	brne	.+2      	; 0x8e6 <process_command+0x1e>
 8e4:	40 c0       	rjmp	.+128    	; 0x966 <__stack+0x67>
 8e6:	82 30       	cpi	r24, 0x02	; 2
 8e8:	08 f0       	brcs	.+2      	; 0x8ec <process_command+0x24>
 8ea:	c2 c0       	rjmp	.+388    	; 0xa70 <__stack+0x171>
 8ec:	23 c0       	rjmp	.+70     	; 0x934 <__stack+0x35>
 8ee:	85 30       	cpi	r24, 0x05	; 5
 8f0:	09 f4       	brne	.+2      	; 0x8f4 <process_command+0x2c>
 8f2:	5b c0       	rjmp	.+182    	; 0x9aa <__stack+0xab>
 8f4:	86 30       	cpi	r24, 0x06	; 6
 8f6:	08 f0       	brcs	.+2      	; 0x8fa <process_command+0x32>
 8f8:	65 c0       	rjmp	.+202    	; 0x9c4 <__stack+0xc5>
 8fa:	4a c0       	rjmp	.+148    	; 0x990 <__stack+0x91>
 8fc:	8c 30       	cpi	r24, 0x0C	; 12
 8fe:	09 f4       	brne	.+2      	; 0x902 <__stack+0x3>
 900:	ba c0       	rjmp	.+372    	; 0xa76 <__stack+0x177>
 902:	8d 30       	cpi	r24, 0x0D	; 13
 904:	50 f4       	brcc	.+20     	; 0x91a <__stack+0x1b>
 906:	8a 30       	cpi	r24, 0x0A	; 10
 908:	09 f4       	brne	.+2      	; 0x90c <__stack+0xd>
 90a:	b2 c0       	rjmp	.+356    	; 0xa70 <__stack+0x171>
 90c:	8b 30       	cpi	r24, 0x0B	; 11
 90e:	08 f0       	brcs	.+2      	; 0x912 <__stack+0x13>
 910:	af c0       	rjmp	.+350    	; 0xa70 <__stack+0x171>
 912:	88 30       	cpi	r24, 0x08	; 8
 914:	09 f0       	breq	.+2      	; 0x918 <__stack+0x19>
 916:	fb c0       	rjmp	.+502    	; 0xb0e <__stack+0x20f>
 918:	9a c0       	rjmp	.+308    	; 0xa4e <__stack+0x14f>
 91a:	8e 30       	cpi	r24, 0x0E	; 14
 91c:	09 f4       	brne	.+2      	; 0x920 <__stack+0x21>
 91e:	bd c0       	rjmp	.+378    	; 0xa9a <__stack+0x19b>
 920:	8e 30       	cpi	r24, 0x0E	; 14
 922:	08 f4       	brcc	.+2      	; 0x926 <__stack+0x27>
 924:	b1 c0       	rjmp	.+354    	; 0xa88 <__stack+0x189>
 926:	8f 30       	cpi	r24, 0x0F	; 15
 928:	09 f4       	brne	.+2      	; 0x92c <__stack+0x2d>
 92a:	d2 c0       	rjmp	.+420    	; 0xad0 <__stack+0x1d1>
 92c:	80 31       	cpi	r24, 0x10	; 16
 92e:	09 f0       	breq	.+2      	; 0x932 <__stack+0x33>
 930:	ee c0       	rjmp	.+476    	; 0xb0e <__stack+0x20f>
 932:	6c c0       	rjmp	.+216    	; 0xa0c <__stack+0x10d>

		case SUBCOMMAND_SETALL:

				set_all(buffer[2], buffer[3], buffer[4]);
 934:	40 91 95 09 	lds	r20, 0x0995
 938:	30 91 96 09 	lds	r19, 0x0996
 93c:	20 91 97 09 	lds	r18, 0x0997
 940:	80 e0       	ldi	r24, 0x00	; 0
 942:	90 e0       	ldi	r25, 0x00	; 0

	uint16_t i;

	for(i = 0 ; i < 64 ; i++)
	{
		red_frame[i] = r;
 944:	fc 01       	movw	r30, r24
 946:	e5 5b       	subi	r30, 0xB5	; 181
 948:	f6 4f       	sbci	r31, 0xF6	; 246
 94a:	40 83       	st	Z, r20
		green_frame[i] = g;
 94c:	fc 01       	movw	r30, r24
 94e:	e8 5a       	subi	r30, 0xA8	; 168
 950:	f5 4f       	sbci	r31, 0xF5	; 245
 952:	30 83       	st	Z, r19
		blue_frame[i] = b;
 954:	fc 01       	movw	r30, r24
 956:	e8 5e       	subi	r30, 0xE8	; 232
 958:	f5 4f       	sbci	r31, 0xF5	; 245
 95a:	20 83       	st	Z, r18
void set_all(uint8_t r, uint8_t g, uint8_t b)
{

	uint16_t i;

	for(i = 0 ; i < 64 ; i++)
 95c:	01 96       	adiw	r24, 0x01	; 1
 95e:	80 34       	cpi	r24, 0x40	; 64
 960:	91 05       	cpc	r25, r1
 962:	81 f7       	brne	.-32     	; 0x944 <__stack+0x45>
 964:	08 95       	ret

			break;

		case SUBCOMMAND_SETNUMBOARDS:

				if(buffer[2] > 0 && buffer[2] < 9) {
 966:	80 91 95 09 	lds	r24, 0x0995
 96a:	88 23       	and	r24, r24
 96c:	09 f4       	brne	.+2      	; 0x970 <__stack+0x71>
 96e:	cf c0       	rjmp	.+414    	; 0xb0e <__stack+0x20f>
 970:	80 91 95 09 	lds	r24, 0x0995
 974:	89 30       	cpi	r24, 0x09	; 9
 976:	08 f0       	brcs	.+2      	; 0x97a <__stack+0x7b>
 978:	ca c0       	rjmp	.+404    	; 0xb0e <__stack+0x20f>

					NUM_BOARDS = buffer[2];
 97a:	80 91 95 09 	lds	r24, 0x0995
 97e:	80 93 44 09 	sts	0x0944, r24

					write_to_EEPROM(NUM_BOARDS_ADDRESS, NUM_BOARDS);
 982:	60 91 44 09 	lds	r22, 0x0944
 986:	81 e0       	ldi	r24, 0x01	; 1
 988:	90 e0       	ldi	r25, 0x00	; 0
 98a:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <write_to_EEPROM>
 98e:	08 95       	ret
				update_buffer();
			break;


		case SUBCOMMAND_SETFORECOLOR: //    	uint[3] color
				foreColor[COLOR_CHANNEL_RED]   = buffer[2];
 990:	80 91 95 09 	lds	r24, 0x0995
 994:	80 93 15 0a 	sts	0x0A15, r24
				foreColor[COLOR_CHANNEL_GREEN] = buffer[3];
 998:	80 91 96 09 	lds	r24, 0x0996
 99c:	80 93 16 0a 	sts	0x0A16, r24
				foreColor[COLOR_CHANNEL_BLUE]  = buffer[4];
 9a0:	80 91 97 09 	lds	r24, 0x0997
 9a4:	80 93 17 0a 	sts	0x0A17, r24
 9a8:	08 95       	ret
				// update_buffer();
			break;

		case SUBCOMMAND_SETBACKCOLOR: //    	uint[3] color
				backColor[COLOR_CHANNEL_RED]   = buffer[2];
 9aa:	80 91 95 09 	lds	r24, 0x0995
 9ae:	80 93 99 0a 	sts	0x0A99, r24
				backColor[COLOR_CHANNEL_GREEN] = buffer[3];
 9b2:	80 91 96 09 	lds	r24, 0x0996
 9b6:	80 93 9a 0a 	sts	0x0A9A, r24
				backColor[COLOR_CHANNEL_BLUE]  = buffer[4];
 9ba:	80 91 97 09 	lds	r24, 0x0997
 9be:	80 93 9b 0a 	sts	0x0A9B, r24
 9c2:	08 95       	ret
				// update_buffer();
			break;
 9c4:	eb e8       	ldi	r30, 0x8B	; 139
 9c6:	f9 e0       	ldi	r31, 0x09	; 9
}

void draw_clear()
{
	
	for (int i = 0; i < ROWS; i++) pointBuffer[i] = 0;
 9c8:	11 92       	st	Z+, r1
 9ca:	89 e0       	ldi	r24, 0x09	; 9
 9cc:	e3 39       	cpi	r30, 0x93	; 147
 9ce:	f8 07       	cpc	r31, r24
 9d0:	d9 f7       	brne	.-10     	; 0x9c8 <__stack+0xc9>
 9d2:	4e c0       	rjmp	.+156    	; 0xa70 <__stack+0x171>
				draw_clear();
				update_buffer();
			break;

		case SUBCOMMAND_DRAWPOINT:   //        int x, int y
		        if ((buffer[2] < COLS) && (buffer[3] < ROWS)) {
 9d4:	80 91 95 09 	lds	r24, 0x0995
 9d8:	88 30       	cpi	r24, 0x08	; 8
 9da:	08 f0       	brcs	.+2      	; 0x9de <__stack+0xdf>
 9dc:	98 c0       	rjmp	.+304    	; 0xb0e <__stack+0x20f>
 9de:	80 91 96 09 	lds	r24, 0x0996
 9e2:	88 30       	cpi	r24, 0x08	; 8
 9e4:	08 f0       	brcs	.+2      	; 0x9e8 <__stack+0xe9>
 9e6:	93 c0       	rjmp	.+294    	; 0xb0e <__stack+0x20f>
				    pointBuffer[buffer[3]] |= (1 << buffer[2]);
 9e8:	e0 91 96 09 	lds	r30, 0x0996
 9ec:	f0 e0       	ldi	r31, 0x00	; 0
 9ee:	20 91 95 09 	lds	r18, 0x0995
 9f2:	e5 57       	subi	r30, 0x75	; 117
 9f4:	f6 4f       	sbci	r31, 0xF6	; 246
 9f6:	81 e0       	ldi	r24, 0x01	; 1
 9f8:	90 e0       	ldi	r25, 0x00	; 0
 9fa:	02 c0       	rjmp	.+4      	; 0xa00 <__stack+0x101>
 9fc:	88 0f       	add	r24, r24
 9fe:	99 1f       	adc	r25, r25
 a00:	2a 95       	dec	r18
 a02:	e2 f7       	brpl	.-8      	; 0x9fc <__stack+0xfd>
 a04:	20 81       	ld	r18, Z
 a06:	28 2b       	or	r18, r24
 a08:	20 83       	st	Z, r18
 a0a:	1c c0       	rjmp	.+56     	; 0xa44 <__stack+0x145>
					update_buffer_row(buffer[3]);
				}
			break;

		case SUBCOMMAND_CLEARPOINT:   //        int x, int y
		        if ((buffer[2] < COLS) && (buffer[3] < ROWS)) {
 a0c:	80 91 95 09 	lds	r24, 0x0995
 a10:	88 30       	cpi	r24, 0x08	; 8
 a12:	08 f0       	brcs	.+2      	; 0xa16 <__stack+0x117>
 a14:	7c c0       	rjmp	.+248    	; 0xb0e <__stack+0x20f>
 a16:	80 91 96 09 	lds	r24, 0x0996
 a1a:	88 30       	cpi	r24, 0x08	; 8
 a1c:	08 f0       	brcs	.+2      	; 0xa20 <__stack+0x121>
 a1e:	77 c0       	rjmp	.+238    	; 0xb0e <__stack+0x20f>
				    pointBuffer[buffer[3]] &= ~(1 << buffer[2]);
 a20:	e0 91 96 09 	lds	r30, 0x0996
 a24:	f0 e0       	ldi	r31, 0x00	; 0
 a26:	20 91 95 09 	lds	r18, 0x0995
 a2a:	e5 57       	subi	r30, 0x75	; 117
 a2c:	f6 4f       	sbci	r31, 0xF6	; 246
 a2e:	81 e0       	ldi	r24, 0x01	; 1
 a30:	90 e0       	ldi	r25, 0x00	; 0
 a32:	02 c0       	rjmp	.+4      	; 0xa38 <__stack+0x139>
 a34:	88 0f       	add	r24, r24
 a36:	99 1f       	adc	r25, r25
 a38:	2a 95       	dec	r18
 a3a:	e2 f7       	brpl	.-8      	; 0xa34 <__stack+0x135>
 a3c:	80 95       	com	r24
 a3e:	20 81       	ld	r18, Z
 a40:	82 23       	and	r24, r18
 a42:	80 83       	st	Z, r24
					update_buffer_row(buffer[3]);
 a44:	80 91 96 09 	lds	r24, 0x0996
 a48:	0e 94 8d 01 	call	0x31a	; 0x31a <update_buffer_row>
 a4c:	08 95       	ret
				}
			break;

		case SUBCOMMAND_DRAWCHAR:    //        int x, int y, char c

		        if ((buffer[4] > 31) && (buffer[4] < 128)) {
 a4e:	80 91 97 09 	lds	r24, 0x0997
 a52:	80 32       	cpi	r24, 0x20	; 32
 a54:	08 f4       	brcc	.+2      	; 0xa58 <__stack+0x159>
 a56:	5b c0       	rjmp	.+182    	; 0xb0e <__stack+0x20f>
 a58:	80 91 97 09 	lds	r24, 0x0997
 a5c:	87 fd       	sbrc	r24, 7
 a5e:	57 c0       	rjmp	.+174    	; 0xb0e <__stack+0x20f>

                    draw_character(buffer[2], buffer[3], buffer[4]);
 a60:	80 91 95 09 	lds	r24, 0x0995
 a64:	60 91 96 09 	lds	r22, 0x0996
 a68:	40 91 97 09 	lds	r20, 0x0997
 a6c:	0e 94 3f 02 	call	0x47e	; 0x47e <draw_character>
		case SUBCOMMAND_DRAWCOL:    //        uint col, uint data
				update_buffer();
			break;

		case SUBCOMMAND_DRAWALL:    //        uint[8] data
				update_buffer();
 a70:	0e 94 de 01 	call	0x3bc	; 0x3bc <update_buffer>
 a74:	08 95       	ret
			break;

		case SUBCOMMAND_SHIFTLEFT:    //        uint[3] color
				shift_left(buffer[2], buffer[3], buffer[4]);
 a76:	80 91 95 09 	lds	r24, 0x0995
 a7a:	60 91 96 09 	lds	r22, 0x0996
 a7e:	40 91 97 09 	lds	r20, 0x0997
 a82:	0e 94 16 02 	call	0x42c	; 0x42c <shift_left>
 a86:	08 95       	ret
			break;

		case SUBCOMMAND_SHIFTRIGHT:    //        uint[3] color
				shift_right(buffer[2], buffer[3], buffer[4]);
 a88:	80 91 95 09 	lds	r24, 0x0995
 a8c:	60 91 96 09 	lds	r22, 0x0996
 a90:	40 91 97 09 	lds	r20, 0x0997
 a94:	0e 94 f0 01 	call	0x3e0	; 0x3e0 <shift_right>
 a98:	08 95       	ret
			break;

        case SUBCOMMAND_DRAWLINEV:
				draw_line_v(buffer[2], buffer[3], buffer[4],  buffer[5]);
 a9a:	40 91 95 09 	lds	r20, 0x0995
 a9e:	30 91 96 09 	lds	r19, 0x0996
 aa2:	20 91 97 09 	lds	r18, 0x0997
 aa6:	90 91 98 09 	lds	r25, 0x0998
 aaa:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t y = 0; y < 8; y++) 
	{

		uint8_t index = (y * 8) + x;

		red_frame[index] = r;
 aac:	e8 2f       	mov	r30, r24
 aae:	e4 0f       	add	r30, r20
 ab0:	f0 e0       	ldi	r31, 0x00	; 0
 ab2:	df 01       	movw	r26, r30
 ab4:	a5 5b       	subi	r26, 0xB5	; 181
 ab6:	b6 4f       	sbci	r27, 0xF6	; 246
 ab8:	3c 93       	st	X, r19
		green_frame[index] = g;
 aba:	df 01       	movw	r26, r30
 abc:	a8 5a       	subi	r26, 0xA8	; 168
 abe:	b5 4f       	sbci	r27, 0xF5	; 245
 ac0:	2c 93       	st	X, r18
		blue_frame[index] = b;
 ac2:	e8 5e       	subi	r30, 0xE8	; 232
 ac4:	f5 4f       	sbci	r31, 0xF5	; 245
 ac6:	90 83       	st	Z, r25
 ac8:	88 5f       	subi	r24, 0xF8	; 248
	}
}

void draw_line_v(uint8_t x, uint8_t r, uint8_t g, uint8_t b)
{
	for (uint8_t y = 0; y < 8; y++) 
 aca:	80 34       	cpi	r24, 0x40	; 64
 acc:	79 f7       	brne	.-34     	; 0xaac <__stack+0x1ad>
 ace:	08 95       	ret
        case SUBCOMMAND_DRAWLINEV:
				draw_line_v(buffer[2], buffer[3], buffer[4],  buffer[5]);
			break;

        case SUBCOMMAND_DRAWLINEH:
				draw_line_h(buffer[2], buffer[3], buffer[4],  buffer[5]);
 ad0:	20 91 95 09 	lds	r18, 0x0995
 ad4:	50 91 96 09 	lds	r21, 0x0996
 ad8:	40 91 97 09 	lds	r20, 0x0997
 adc:	30 91 98 09 	lds	r19, 0x0998
{

	for (int x = 0; x < 8; x++) 
	{

		uint8_t index = (y * 8) + x;
 ae0:	22 0f       	add	r18, r18
 ae2:	22 0f       	add	r18, r18
 ae4:	22 0f       	add	r18, r18
 ae6:	80 e0       	ldi	r24, 0x00	; 0
 ae8:	90 e0       	ldi	r25, 0x00	; 0

		red_frame[index] = r;
 aea:	e2 2f       	mov	r30, r18
 aec:	e8 0f       	add	r30, r24
 aee:	f0 e0       	ldi	r31, 0x00	; 0
 af0:	df 01       	movw	r26, r30
 af2:	a5 5b       	subi	r26, 0xB5	; 181
 af4:	b6 4f       	sbci	r27, 0xF6	; 246
 af6:	5c 93       	st	X, r21
		green_frame[index] = g;
 af8:	df 01       	movw	r26, r30
 afa:	a8 5a       	subi	r26, 0xA8	; 168
 afc:	b5 4f       	sbci	r27, 0xF5	; 245
 afe:	4c 93       	st	X, r20
		blue_frame[index] = b;
 b00:	e8 5e       	subi	r30, 0xE8	; 232
 b02:	f5 4f       	sbci	r31, 0xF5	; 245
 b04:	30 83       	st	Z, r19


void draw_line_h(uint8_t y, uint8_t r, uint8_t g, uint8_t b)
{

	for (int x = 0; x < 8; x++) 
 b06:	01 96       	adiw	r24, 0x01	; 1
 b08:	88 30       	cpi	r24, 0x08	; 8
 b0a:	91 05       	cpc	r25, r1
 b0c:	71 f7       	brne	.-36     	; 0xaea <__stack+0x1eb>
 b0e:	08 95       	ret

00000b10 <ioinit>:
Purpose:	Initialize I/O, Setup SPI Hardware
Parameters:	None
Return:		None
*/
void ioinit (void)
{
 b10:	1f 93       	push	r17
	//1 = Output, 0 = Input
	DDRB = (1<<MISO);	//Enable internal pull-up resistor on MISO
 b12:	80 e1       	ldi	r24, 0x10	; 16
 b14:	84 b9       	out	0x04, r24	; 4
	PORTB = (1<<MOSI)|(1<<CS)|(1<<SCK);	//Set SPI Outputs	
 b16:	8c e2       	ldi	r24, 0x2C	; 44
 b18:	85 b9       	out	0x05, r24	; 5
	
	DDRC = 0x1F;	//Set outputs to the shift registers
 b1a:	8f e1       	ldi	r24, 0x1F	; 31
 b1c:	87 b9       	out	0x07, r24	; 7
	DDRD = 0xFF;	//All Port D pins are outputs to the Sync Driver
 b1e:	8f ef       	ldi	r24, 0xFF	; 255
 b20:	8a b9       	out	0x0a, r24	; 10

	//Set initial pin states
	sbi(PORTC, CLK);
 b22:	40 9a       	sbi	0x08, 0	; 8
	sbi(PORTC, CLR);
 b24:	43 9a       	sbi	0x08, 3	; 8
	sbi(PORTC, DATA);
 b26:	41 9a       	sbi	0x08, 1	; 8
	sbi(PORTC, LATCH);
 b28:	42 9a       	sbi	0x08, 2	; 8
	sbi(PORTC, EN); 
 b2a:	44 9a       	sbi	0x08, 4	; 8
	
	//Setup the SPI Hardware
	SPCR = (1<<SPE) | (1<<SPIE); //Enable SPI, Enable SPI Interrupts
 b2c:	80 ec       	ldi	r24, 0xC0	; 192
 b2e:	8c bd       	out	0x2c, r24	; 44
//		Data=read_from_EEPROM(0);
unsigned char read_from_EEPROM(unsigned int Address)
{
	//Interrupts are globally disabled!
	
	while(EECR & (1<<EEPE));	//Wait for last Write to complete
 b30:	f9 99       	sbic	0x1f, 1	; 31
 b32:	fe cf       	rjmp	.-4      	; 0xb30 <ioinit+0x20>
	EEAR = Address;				//Assign the Address Register with "Address"
 b34:	12 bc       	out	0x22, r1	; 34
 b36:	11 bc       	out	0x21, r1	; 33
	EECR |= (1<<EERE); 			//Start Read by writing to EER
 b38:	f8 9a       	sbi	0x1f, 0	; 31
	return EEDR;				//EEPROM Data is returned
 b3a:	80 b5       	in	r24, 0x20	; 32
	
	//Setup the SPI Hardware
	SPCR = (1<<SPE) | (1<<SPIE); //Enable SPI, Enable SPI Interrupts
	
	//Load the NUM_BOARDS parameter from EEPROM
	RUN_COUNT = read_from_EEPROM(RUN_COUNT_ADDRESS);
 b3c:	80 93 45 09 	sts	0x0945, r24
	if(RUN_COUNT == 0xFF){
 b40:	80 91 45 09 	lds	r24, 0x0945
 b44:	8f 3f       	cpi	r24, 0xFF	; 255
 b46:	91 f4       	brne	.+36     	; 0xb6c <ioinit+0x5c>
		RUN_COUNT = 1;
 b48:	11 e0       	ldi	r17, 0x01	; 1
 b4a:	10 93 45 09 	sts	0x0945, r17
		write_to_EEPROM(RUN_COUNT_ADDRESS, RUN_COUNT);
 b4e:	60 91 45 09 	lds	r22, 0x0945
 b52:	80 e0       	ldi	r24, 0x00	; 0
 b54:	90 e0       	ldi	r25, 0x00	; 0
 b56:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <write_to_EEPROM>
		NUM_BOARDS=1;
 b5a:	10 93 44 09 	sts	0x0944, r17
		write_to_EEPROM(NUM_BOARDS_ADDRESS, NUM_BOARDS);
 b5e:	60 91 44 09 	lds	r22, 0x0944
 b62:	81 e0       	ldi	r24, 0x01	; 1
 b64:	90 e0       	ldi	r25, 0x00	; 0
 b66:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <write_to_EEPROM>
 b6a:	28 c0       	rjmp	.+80     	; 0xbbc <ioinit+0xac>
//		Data=read_from_EEPROM(0);
unsigned char read_from_EEPROM(unsigned int Address)
{
	//Interrupts are globally disabled!
	
	while(EECR & (1<<EEPE));	//Wait for last Write to complete
 b6c:	f9 99       	sbic	0x1f, 1	; 31
 b6e:	fe cf       	rjmp	.-4      	; 0xb6c <ioinit+0x5c>
	EEAR = Address;				//Assign the Address Register with "Address"
 b70:	12 bc       	out	0x22, r1	; 34
 b72:	11 bc       	out	0x21, r1	; 33
	EECR |= (1<<EERE); 			//Start Read by writing to EER
 b74:	f8 9a       	sbi	0x1f, 0	; 31
	return EEDR;				//EEPROM Data is returned
 b76:	80 b5       	in	r24, 0x20	; 32
		write_to_EEPROM(RUN_COUNT_ADDRESS, RUN_COUNT);
		NUM_BOARDS=1;
		write_to_EEPROM(NUM_BOARDS_ADDRESS, NUM_BOARDS);
	}
	else{
		RUN_COUNT = read_from_EEPROM(RUN_COUNT_ADDRESS);
 b78:	80 93 45 09 	sts	0x0945, r24
		if(RUN_COUNT < 10){
 b7c:	80 91 45 09 	lds	r24, 0x0945
 b80:	8a 30       	cpi	r24, 0x0A	; 10
 b82:	58 f4       	brcc	.+22     	; 0xb9a <ioinit+0x8a>
			RUN_COUNT+=1;
 b84:	80 91 45 09 	lds	r24, 0x0945
 b88:	8f 5f       	subi	r24, 0xFF	; 255
 b8a:	80 93 45 09 	sts	0x0945, r24
			write_to_EEPROM(RUN_COUNT_ADDRESS, RUN_COUNT);
 b8e:	60 91 45 09 	lds	r22, 0x0945
 b92:	80 e0       	ldi	r24, 0x00	; 0
 b94:	90 e0       	ldi	r25, 0x00	; 0
 b96:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <write_to_EEPROM>
//		Data=read_from_EEPROM(0);
unsigned char read_from_EEPROM(unsigned int Address)
{
	//Interrupts are globally disabled!
	
	while(EECR & (1<<EEPE));	//Wait for last Write to complete
 b9a:	f9 99       	sbic	0x1f, 1	; 31
 b9c:	fe cf       	rjmp	.-4      	; 0xb9a <ioinit+0x8a>
	EEAR = Address;				//Assign the Address Register with "Address"
 b9e:	81 e0       	ldi	r24, 0x01	; 1
 ba0:	90 e0       	ldi	r25, 0x00	; 0
 ba2:	92 bd       	out	0x22, r25	; 34
 ba4:	81 bd       	out	0x21, r24	; 33
	EECR |= (1<<EERE); 			//Start Read by writing to EER
 ba6:	f8 9a       	sbi	0x1f, 0	; 31
	return EEDR;				//EEPROM Data is returned
 ba8:	80 b5       	in	r24, 0x20	; 32
		RUN_COUNT = read_from_EEPROM(RUN_COUNT_ADDRESS);
		if(RUN_COUNT < 10){
			RUN_COUNT+=1;
			write_to_EEPROM(RUN_COUNT_ADDRESS, RUN_COUNT);
		}
		NUM_BOARDS=read_from_EEPROM(NUM_BOARDS_ADDRESS);
 baa:	80 93 44 09 	sts	0x0944, r24
		if(NUM_BOARDS > 8)NUM_BOARDS=1;
 bae:	80 91 44 09 	lds	r24, 0x0944
 bb2:	89 30       	cpi	r24, 0x09	; 9
 bb4:	18 f0       	brcs	.+6      	; 0xbbc <ioinit+0xac>
 bb6:	81 e0       	ldi	r24, 0x01	; 1
 bb8:	80 93 44 09 	sts	0x0944, r24
	}
		
}
 bbc:	1f 91       	pop	r17
 bbe:	08 95       	ret

00000bc0 <main>:
/*********************************************************
						Main Code
*********************************************************/
int main (void)
{
	ioinit ();
 bc0:	0e 94 88 05 	call	0xb10	; 0xb10 <ioinit>
	
	//Make sure all the pixels are working
	// if(RUN_COUNT < 10)	
	splash_screen();
 bc4:	0e 94 cb 03 	call	0x796	; 0x796 <splash_screen>
	blue_frame[(NUM_BOARDS-1)+4] = 31;
	blue_frame[(NUM_BOARDS-1)+5] = 31;
    */

	
	foreColor[COLOR_CHANNEL_RED]   = 0xFF;
 bc8:	8f ef       	ldi	r24, 0xFF	; 255
 bca:	80 93 15 0a 	sts	0x0A15, r24
	foreColor[COLOR_CHANNEL_GREEN] = 0x00;
 bce:	10 92 16 0a 	sts	0x0A16, r1
	foreColor[COLOR_CHANNEL_BLUE]  = 0x00;
 bd2:	10 92 17 0a 	sts	0x0A17, r1

	backColor[COLOR_CHANNEL_RED]   = 0x00;
 bd6:	10 92 99 0a 	sts	0x0A99, r1
	backColor[COLOR_CHANNEL_GREEN] = 0x00;
 bda:	10 92 9a 0a 	sts	0x0A9A, r1
	backColor[COLOR_CHANNEL_BLUE]  = 0x00;
 bde:	10 92 9b 0a 	sts	0x0A9B, r1
 be2:	eb e8       	ldi	r30, 0x8B	; 139
 be4:	f9 e0       	ldi	r31, 0x09	; 9
}

void draw_clear()
{
	
	for (int i = 0; i < ROWS; i++) pointBuffer[i] = 0;
 be6:	11 92       	st	Z+, r1
 be8:	89 e0       	ldi	r24, 0x09	; 9
 bea:	e3 39       	cpi	r30, 0x93	; 147
 bec:	f8 07       	cpc	r31, r24
 bee:	d9 f7       	brne	.-10     	; 0xbe6 <main+0x26>

	draw_clear();
	//draw_character(1,1,'Y');
    //draw_character(4,1,'U');

	update_buffer();
 bf0:	0e 94 de 01 	call	0x3bc	; 0x3bc <update_buffer>

	//draw_line_v(3,0xFF,0x00,0x00);
	//draw_line_h(3,0x00,0xFF,0x00);
	
	//Enable Global Interrupts
	sei();
 bf4:	78 94       	sei
	while(1)
	{
        if (PINB & (1<<CS)) //If CS goes high, SPI com is complete
 bf6:	1a 9b       	sbis	0x03, 2	; 3
 bf8:	0a c0       	rjmp	.+20     	; 0xc0e <main+0x4e>
		{
			frame_index = 0;//Reset the frame index
 bfa:	10 92 42 09 	sts	0x0942, r1

			command_mode = 0;
 bfe:	10 92 46 09 	sts	0x0946, r1

			byte_count = 0;
 c02:	10 92 14 0a 	sts	0x0A14, r1
 c06:	10 92 13 0a 	sts	0x0A13, r1

			bytes_expected = 0;
 c0a:	10 92 49 09 	sts	0x0949, r1
		}

		if (process_command_now) {
 c0e:	80 91 48 09 	lds	r24, 0x0948
 c12:	88 23       	and	r24, r24
 c14:	31 f0       	breq	.+12     	; 0xc22 <main+0x62>

			process_command();
 c16:	0e 94 64 04 	call	0x8c8	; 0x8c8 <process_command>
			
			current_subcommand = 0;
 c1a:	10 92 4a 09 	sts	0x094A, r1
			process_command_now = 0;
 c1e:	10 92 48 09 	sts	0x0948, r1

		}

		post_frames(); //Update display with current frame data  
 c22:	0e 94 c1 03 	call	0x782	; 0x782 <post_frames>
		
		//Check to see if there is a new frame to parse
		if (new_frame == 1) parse_frame555();
 c26:	80 91 98 0a 	lds	r24, 0x0A98
 c2a:	81 30       	cpi	r24, 0x01	; 1
 c2c:	11 f4       	brne	.+4      	; 0xc32 <main+0x72>
 c2e:	0e 94 2a 03 	call	0x654	; 0x654 <parse_frame555>
	
		//Increment clicks to determine LED brightness levels for 5 bit color values
		timer_clicks = (timer_clicks + 1) & 0x1F; //0b00011111; //Circular 0 to 1F
 c32:	80 91 43 09 	lds	r24, 0x0943
 c36:	8f 5f       	subi	r24, 0xFF	; 255
 c38:	8f 71       	andi	r24, 0x1F	; 31
 c3a:	80 93 43 09 	sts	0x0943, r24
 c3e:	db cf       	rjmp	.-74     	; 0xbf6 <main+0x36>

00000c40 <read_from_EEPROM>:
//		Data=read_from_EEPROM(0);
unsigned char read_from_EEPROM(unsigned int Address)
{
	//Interrupts are globally disabled!
	
	while(EECR & (1<<EEPE));	//Wait for last Write to complete
 c40:	f9 99       	sbic	0x1f, 1	; 31
 c42:	fe cf       	rjmp	.-4      	; 0xc40 <read_from_EEPROM>
	EEAR = Address;				//Assign the Address Register with "Address"
 c44:	92 bd       	out	0x22, r25	; 34
 c46:	81 bd       	out	0x21, r24	; 33
	EECR |= (1<<EERE); 			//Start Read by writing to EER
 c48:	f8 9a       	sbi	0x1f, 0	; 31
	return EEDR;				//EEPROM Data is returned
 c4a:	80 b5       	in	r24, 0x20	; 32
}
 c4c:	08 95       	ret

00000c4e <_exit>:
 c4e:	f8 94       	cli

00000c50 <__stop_program>:
 c50:	ff cf       	rjmp	.-2      	; 0xc50 <__stop_program>
